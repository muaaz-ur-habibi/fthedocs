{
    "css": [
        [
            {
                "attributes": {
                    "class": [
                        "subtitle"
                    ]
                },
                "children": [],
                "content": "Using Internet Sockets",
                "tag": "p"
            },
            {
                "attributes": {
                    "class": [
                        "author"
                    ]
                },
                "children": [],
                "content": "Brian \u201cBeej Jorgensen\u201d Hall",
                "tag": "p"
            },
            {
                "attributes": {
                    "class": [
                        "date"
                    ]
                },
                "children": [],
                "content": "v3.1.12, Copyright \u00a9 July 17, 2024",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "Hey! Socket programming got you down? Is this stuff just a little too difficult to figure out from the man pages? You want to do cool Internet programming, but you don\u2019t have time to wade through a gob of structs trying to figure out if you have to call bind() before you connect(), etc., etc.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Well, guess what! I\u2019ve already done this nasty business, and I\u2019m dying to share the information with everyone! You\u2019ve come to the right place. This document should give the average competent C programmer the edge s/he needs to get a grip on this networking noise.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "And check it out: I\u2019ve finally caught up with the future (just in the nick of time, too!) and have updated the Guide for IPv6! Enjoy!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "complete and total",
                        "tag": "em"
                    }
                ],
                "content": "This document has been written as a tutorial, not a complete reference. It is probably at its best when read by individuals who are just starting out with socket programming and are looking for a foothold. It is certainly not the complete and total guide to sockets programming, by any means.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "Hopefully, though, it\u2019ll be just enough for those man pages to start making sense\u2026 :-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gcc",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gcc",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#windows"
                        },
                        "children": [],
                        "content": "section on Windows programming",
                        "tag": "a"
                    }
                ],
                "content": "The code contained within this document was compiled on a Linux PC using Gnu\u2019s gcc compiler. It should, however, build on just about any platform that uses gcc. Naturally, this doesn\u2019t apply if you\u2019re programming for Windows\u2014see the section on Windows programming, below.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This official location of this document is:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "There you will also find example code and translations of the guide into various languages.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "To buy nicely bound print copies (some call them \u201cbooks\u201d), visit:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "I\u2019ll appreciate the purchase because it helps sustain my document-writing lifestyle!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-lnsl -lsocket -lresolv",
                        "tag": "code"
                    }
                ],
                "content": "When compiling for Solaris or SunOS, you need to specify some extra command-line switches for linking in the proper libraries. In order to do this, simply add \u201c-lnsl -lsocket -lresolv\u201d to the end of the compile command, like so:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-lxnet",
                        "tag": "code"
                    }
                ],
                "content": "If you still get errors, you could try further adding a -lxnet to the end of that command line. I don\u2019t know what that does, exactly, but some people seem to need it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "setsockopt()",
                        "tag": "code"
                    }
                ],
                "content": "Another place that you might find problems is in the call to setsockopt(). The prototype differs from that on my Linux box, so instead of:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "enter this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "As I don\u2019t have a Sun box, I haven\u2019t tested any of the above information\u2014it\u2019s just what people have told me through email.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "At this point in the guide, historically, I\u2019ve done a bit of bagging on Windows, simply due to the fact that I don\u2019t like it very much. But I should really be fair and tell you that Windows has a huge install base and is obviously a perfectly fine operating system.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "They say absence makes the heart grow fonder, and in this case, I believe it to be true. (Or maybe it\u2019s age.) But what I can say is that after a decade-plus of not using Microsoft OSes for my personal work, I\u2019m much happier! As such, I can sit back and safely say, \u201cSure, feel free to use Windows!\u201d \u2026OK yes, it does make me grit my teeth to say that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://www.linux.com/"
                        },
                        "children": [],
                        "content": "Linux",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn1",
                            "id": "fnref1",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "1",
                                "tag": "sup"
                            }
                        ],
                        "content": "1",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://bsd.org/"
                        },
                        "children": [],
                        "content": "BSD",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn2",
                            "id": "fnref2",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "2",
                                "tag": "sup"
                            }
                        ],
                        "content": "2",
                        "tag": "a"
                    }
                ],
                "content": "So I still encourage you to try Linux1, BSD2, or some flavor of Unix, instead.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But people like what they like, and you Windows folk will be pleased to know that this information is generally applicable to you guys, with a few minor changes, if any.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://learn.microsoft.com/en-us/windows/wsl/"
                        },
                        "children": [],
                        "content": "Windows Subsystem for Linux",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn3",
                            "id": "fnref3",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "3",
                                "tag": "sup"
                            }
                        ],
                        "content": "3",
                        "tag": "a"
                    }
                ],
                "content": "Another thing that you should strongly consider is the Windows Subsystem for Linux3. This basically allows you to install a Linux VM-ish thing on Windows 10. That will also definitely get you situated, and you\u2019ll be able to build and run these programs as is.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://cygwin.com/"
                        },
                        "children": [],
                        "content": "Cygwin",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn4",
                            "id": "fnref4",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "4",
                                "tag": "sup"
                            }
                        ],
                        "content": "4",
                        "tag": "a"
                    }
                ],
                "content": "One cool thing you can do is install Cygwin4, which is a collection of Unix tools for Windows. I\u2019ve heard on the grapevine that doing so allows all these programs to compile unmodified, but I\u2019ve never tried it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But some of you might want to do things the Pure Windows Way. That\u2019s very gutsy of you, and this is what you have to do: run out and get Unix immediately! No, no\u2014I\u2019m kidding. I\u2019m supposed to be Windows-friendly(er) these days\u2026",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This is what you\u2019ll have to do: first, ignore pretty much all of the system header files I mention in here. Instead, include:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "winsock2",
                        "tag": "code"
                    }
                ],
                "content": "winsock2 is the \u201cnew\u201d (circa 1994) version of the Windows socket library.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "windows.h",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "winsock.h",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "winsock2.h",
                        "tag": "code"
                    }
                ],
                "content": "Unfortunately, if you include windows.h, it automatically pulls in the older winsock.h (version 1) header file which conflicts with winsock2.h! Fun times.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "windows.h",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "not",
                        "tag": "em"
                    }
                ],
                "content": "So if you have to include windows.h, you need to define a macro to get it to not include the older header:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "WSAStartup()",
                        "tag": "code"
                    }
                ],
                "content": "Wait! You also have to make a call to WSAStartup() before doing anything else with the sockets library. You pass in the Winsock version you desire to this function (e.g.\u00a0version 2.2). And then you can check the result to make sure that version is available.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The code to do that looks something like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "WSACleanup()",
                        "tag": "code"
                    }
                ],
                "content": "Note that call to WSACleanup() in there. That\u2019s what you want to call when you\u2019re done with the Winsock library.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ws2_32.lib",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Project",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Settings...",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Link",
                        "tag": "code"
                    }
                ],
                "content": "You also have to tell your compiler to link in the Winsock library, called ws2_32.lib for Winsock 2. Under VC++, this can be done through the Project menu, under Settings.... Click the Link tab, and look for the box titled \u201cObject/library modules\u201d. Add \u201cws2_32.lib\u201d (or whichever lib is your preference) to that list.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Or so I hear.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "closesocket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "stdin",
                        "tag": "code"
                    }
                ],
                "content": "Once you do that, the rest of the examples in this tutorial should generally apply, with a few exceptions. For one thing, you can\u2019t use close() to close a socket\u2014you need to use closesocket(), instead. Also, select() only works with socket descriptors, not file descriptors (like 0 for stdin).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://learn.microsoft.com/en-us/cpp/mfc/reference/csocket-class?view=msvc-170"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "CSocket",
                                "tag": "code"
                            }
                        ],
                        "content": "CSocket",
                        "tag": "a"
                    }
                ],
                "content": "There is also a socket class that you can use, CSocket Check your compiler\u2019s help pages for more information.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://learn.microsoft.com/en-us/windows/win32/winsock/windows-sockets-start-page-2"
                        },
                        "children": [],
                        "content": "check out the official page at Microsoft",
                        "tag": "a"
                    }
                ],
                "content": "To get more information about Winsock, check out the official page at Microsoft.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "CreateProcess()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "CreateProcess()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "CreateThread()",
                        "tag": "code"
                    }
                ],
                "content": "Finally, I hear that Windows has no fork() system call which is, unfortunately, used in some of my examples. Maybe you have to link in a POSIX library or something to get it to work, or you can use CreateProcess() instead. fork() takes no arguments, and CreateProcess() takes about 48 billion arguments. If you\u2019re not up to that, the CreateThread() is a little easier to digest\u2026unfortunately a discussion about multithreading is beyond the scope of this document. I can only talk about so much, you know!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://www.tallyhawk.net/WinsockExamples/"
                        },
                        "children": [],
                        "content": "ported a number of the examples",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn5",
                            "id": "fnref5",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "5",
                                "tag": "sup"
                            }
                        ],
                        "content": "5",
                        "tag": "a"
                    }
                ],
                "content": "Extra finally, Steven Mitchell has ported a number of the examples5 to Winsock. Check that stuff out.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "I\u2019m generally available to help out with email questions so feel free to write in, but I can\u2019t guarantee a response. I lead a pretty busy life and there are times when I just can\u2019t answer a question you have. When that\u2019s the case, I usually just delete the message. It\u2019s nothing personal; I just won\u2019t ever have the time to give the detailed answer you require.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "http://www.catb.org/~esr/faqs/smart-questions.html"
                        },
                        "children": [],
                        "content": "How To Ask Questions The Smart Way",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn6",
                            "id": "fnref6",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "6",
                                "tag": "sup"
                            }
                        ],
                        "content": "6",
                        "tag": "a"
                    }
                ],
                "content": "As a rule, the more complex the question, the less likely I am to respond. If you can narrow down your question before mailing it and be sure to include any pertinent information (like platform, compiler, error messages you\u2019re getting, and anything else you think might help me troubleshoot), you\u2019re much more likely to get a response. For more pointers, read ESR\u2019s document, How To Ask Questions The Smart Way6.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "If you don\u2019t get a response, hack on it some more, try to find the answer, and if it\u2019s still elusive, then write me again with the information you\u2019ve found and hopefully it will be enough for me to help out.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fully",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "Now that I\u2019ve badgered you about how to write and not write me, I\u2019d just like to let you know that I fully appreciate all the praise the guide has received over the years. It\u2019s a real morale boost, and it gladdens me to hear that it is being used for good! :-) Thank you!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "beej@beej.us"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "beej@beej.us",
                                "tag": "code"
                            }
                        ],
                        "content": "beej@beej.us",
                        "tag": "a"
                    }
                ],
                "content": " You are more than welcome to mirror this site, whether publicly or privately. If you publicly mirror the site and want me to link to it from the main page, drop me a line at beej@beej.us.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "beej@beej.us"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "beej@beej.us",
                                "tag": "code"
                            }
                        ],
                        "content": "beej@beej.us",
                        "tag": "a"
                    }
                ],
                "content": " If you want to translate the guide into another language, write me at beej@beej.us and I\u2019ll link to your translation from the main page. Feel free to add your name and contact info to the translation.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This source markdown document uses UTF-8 encoding.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#legal"
                        },
                        "children": [],
                        "content": "Copyright, Distribution, and Legal",
                        "tag": "a"
                    }
                ],
                "content": "Please note the license restrictions in the Copyright, Distribution, and Legal section, below.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "If you want me to host the translation, just ask. I\u2019ll also link to it if you want to host it; either way is fine.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Beej\u2019s Guide to Network Programming is Copyright \u00a9 2019 Brian \u201cBeej Jorgensen\u201d Hall.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "With specific exceptions for source code and translations, below, this work is licensed under the Creative Commons Attribution- Noncommercial- No Derivative Works 3.0 License. To view a copy of this license, visit",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://creativecommons.org/licenses/by-nc-nd/3.0/"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "https://creativecommons.org/licenses/by-nc-nd/3.0/",
                                "tag": "code"
                            }
                        ],
                        "content": "https://creativecommons.org/licenses/by-nc-nd/3.0/",
                        "tag": "a"
                    }
                ],
                "content": "https://creativecommons.org/licenses/by-nc-nd/3.0/",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "One specific exception to the \u201cNo Derivative Works\u201d portion of the license is as follows: this guide may be freely translated into any language, provided the translation is accurate, and the guide is reprinted in its entirety. The same license restrictions apply to the translation as to the original guide. The translation may also include the name and contact information for the translator.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The C source code presented in this document is hereby granted to the public domain, and is completely free of any license restriction.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Educators are freely encouraged to recommend or supply copies of this guide to their students.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Unless otherwise mutually agreed by the parties in writing, the author offers the work as-is and makes no representations or warranties of any kind concerning the work, express, implied, statutory or otherwise, including, without limitation, warranties of title, merchantability, fitness for a particular purpose, noninfringement, or the absence of latent or other defects, accuracy, or the presence of absence of errors, whether or not discoverable.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Except to the extent required by applicable law, in no event will the author be liable to you on any legal theory for any special, incidental, consequential, punitive or exemplary damages arising out of the use of the work, even if the author has been advised of the possibility of such damages.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "mailto:beej@beej.us"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "beej@beej.us",
                                "tag": "code"
                            }
                        ],
                        "content": "beej@beej.us",
                        "tag": "a"
                    }
                ],
                "content": "Contact beej@beej.us for more information.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Thanks to everyone who has helped in the past and future with me getting this guide written. And thank you to all the people who produce the Free software and packages that I use to make the Guide: GNU, Linux, Slackware, vim, Python, Inkscape, pandoc, many others. And finally a big thank-you to the literally thousands of you who have written in with suggestions for improvements and words of encouragement.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "I dedicate this guide to some of my biggest heroes and inpirators in the world of computers: Donald Knuth, Bruce Schneier, W. Richard Stevens, and The Woz, my Readership, and the entire Free and Open Source Software Community.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This book is written in Markdown using the vim editor on an Arch Linux box loaded with GNU tools. The cover \u201cart\u201d and diagrams are produced with Inkscape. The Markdown is converted to HTML and LaTex/PDF by Python, Pandoc and XeLaTeX, using Liberation fonts. The toolchain is composed of 100% Free and Open Source Software.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "You hear talk of \u201csockets\u201d all the time, and perhaps you are wondering just what they are exactly. Well, they\u2019re this: a way to speak to other programs using standard Unix file descriptors.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "everything",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "is",
                        "tag": "em"
                    }
                ],
                "content": "Ok\u2014you may have heard some Unix hacker state, \u201cJeez, everything in Unix is a file!\u201d What that person may have been talking about is the fact that when Unix programs do any sort of I/O, they do it by reading or writing to a file descriptor. A file descriptor is simply an integer associated with an open file. But (and here\u2019s the catch), that file can be a network connection, a FIFO, a pipe, a terminal, a real on-the-disk file, or just about anything else. Everything in Unix is a file! So when you want to communicate with another program over the Internet you\u2019re gonna do it through a file descriptor, you\u2019d better believe it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#sendman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "man send",
                                "tag": "code"
                            }
                        ],
                        "content": "man send",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#recvman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "man recv",
                                "tag": "code"
                            }
                        ],
                        "content": "man recv",
                        "tag": "a"
                    }
                ],
                "content": "\u201cWhere do I get this file descriptor for network communication, Mr. Smarty-Pants?\u201d is probably the last question on your mind right now, but I\u2019m going to answer it anyway: You make a call to the socket() system routine. It returns the socket descriptor, and you communicate through it using the specialized send() and recv() (man send, man recv) socket calls.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "read()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "write()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "\u201cBut, hey!\u201d you might be exclaiming right about now. \u201cIf it\u2019s a file descriptor, why in the name of Neptune can\u2019t I just use the normal read() and write() calls to communicate through the socket?\u201d The short answer is, \u201cYou can!\u201d The longer answer is, \u201cYou can, but send() and recv() offer much greater control over your data transmission.\u201d",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What next? How about this: there are all kinds of sockets. There are DARPA Internet addresses (Internet Sockets), path names on a local node (Unix Sockets), CCITT X.25 addresses (X.25 Sockets that you can safely ignore), and probably many others depending on which Unix flavor you run. This document deals only with the first: Internet Sockets.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What\u2019s this? There are two types of Internet sockets? Yes. Well, no. I\u2019m lying. There are more, but I didn\u2019t want to scare you. I\u2019m only going to talk about two types here. Except for this sentence, where I\u2019m going to tell you that \u201cRaw Sockets\u201d are also very powerful and you should look them up.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#connect"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "connect()",
                                "tag": "code"
                            }
                        ],
                        "content": "connect()",
                        "tag": "a"
                    }
                ],
                "content": "All right, already. What are the two types? One is \u201cStream Sockets\u201d; the other is \u201cDatagram Sockets\u201d, which may hereafter be referred to as \u201cSOCK_STREAM\u201d and \u201cSOCK_DGRAM\u201d, respectively. Datagram sockets are sometimes called \u201cconnectionless sockets\u201d. (Though they can be connect()\u2019d if you really want. See connect(), below.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "la la la la",
                        "tag": "em"
                    }
                ],
                "content": "Stream sockets are reliable two-way connected communication streams. If you output two items into the socket in the order \u201c1, 2\u201d, they will arrive in the order \u201c1, 2\u201d at the opposite end. They will also be error-free. I\u2019m so certain, in fact, they will be error-free, that I\u2019m just going to put my fingers in my ears and chant la la la la if anyone tries to claim otherwise.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ssh",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "GET / HTTP/1.0",
                        "tag": "code"
                    }
                ],
                "content": "What uses stream sockets? Well, you may have heard of the telnet or ssh applications, yes? They use stream sockets. All the characters you type need to arrive in the same order you type them, right? Also, web browsers use the Hypertext Transfer Protocol (HTTP) which uses stream sockets to get pages. Indeed, if you telnet to a web site on port 80, and type \u201cGET / HTTP/1.0\u201d and hit RETURN twice, it\u2019ll dump the HTML back at you!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/telnot.c"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "telnot",
                                "tag": "code"
                            }
                        ],
                        "content": "telnot",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn7",
                            "id": "fnref7",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "7",
                                "tag": "sup"
                            }
                        ],
                        "content": "7",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc854"
                        },
                        "children": [],
                        "content": "spec\u2019d networking protocol",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn8",
                            "id": "fnref8",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "8",
                                "tag": "sup"
                            }
                        ],
                        "content": "8",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnot",
                        "tag": "code"
                    }
                ],
                "content": "If you don\u2019t have telnet installed and don\u2019t want to install it, or your telnet is being picky about connecting to clients, the guide comes with a telnet-like program called telnot7. This should work well for all the needs of the guide. (Note that telnet is actually a spec\u2019d networking protocol8, and telnot doesn\u2019t implement this protocol at all.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc793"
                        },
                        "children": [],
                        "content": "RFC 793",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn9",
                            "id": "fnref9",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "9",
                                "tag": "sup"
                            }
                        ],
                        "content": "9",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc791"
                        },
                        "children": [],
                        "content": "RFC 791",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn10",
                            "id": "fnref10",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "10",
                                "tag": "sup"
                            }
                        ],
                        "content": "10",
                        "tag": "a"
                    }
                ],
                "content": "How do stream sockets achieve this high level of data transmission quality? They use a protocol called \u201cThe Transmission Control Protocol\u201d, otherwise known as \u201cTCP\u201d (see RFC 7939 for extremely detailed info on TCP). TCP makes sure your data arrives sequentially and error-free. You may have heard \u201cTCP\u201d before as the better half of \u201cTCP/IP\u201d where \u201cIP\u201d stands for \u201cInternet Protocol\u201d (see RFC 79110). IP deals primarily with Internet routing and is not generally responsible for data integrity.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Cool. What about Datagram sockets? Why are they called connectionless? What is the deal, here, anyway? Why are they unreliable? Well, here are some facts: if you send a datagram, it may arrive. It may arrive out of order. If it arrives, the data within the packet will be error-free.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc768"
                        },
                        "children": [],
                        "content": "RFC 768",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn11",
                            "id": "fnref11",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "11",
                                "tag": "sup"
                            }
                        ],
                        "content": "11",
                        "tag": "a"
                    }
                ],
                "content": "Datagram sockets also use IP for routing, but they don\u2019t use TCP; they use the \u201cUser Datagram Protocol\u201d, or \u201cUDP\u201d (see RFC 76811).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tftp",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "dhcpcd",
                        "tag": "code"
                    }
                ],
                "content": "Why are they connectionless? Well, basically, it\u2019s because you don\u2019t have to maintain an open connection as you do with stream sockets. You just build a packet, slap an IP header on it with destination information, and send it out. No connection needed. They are generally used either when a TCP stack is unavailable or when a few dropped packets here and there don\u2019t mean the end of the Universe. Sample applications: tftp (trivial file transfer protocol, a little brother to FTP), dhcpcd (a DHCP client), multiplayer games, streaming audio, video conferencing, etc.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tftp",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "dhcpcd",
                        "tag": "code"
                    }
                ],
                "content": "\u201cWait a minute! tftp and dhcpcd are used to transfer binary applications from one host to another! Data can\u2019t be lost if you expect the application to work when it arrives! What kind of dark magic is this?\u201d",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tftp",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    }
                ],
                "content": "Well, my human friend, tftp and similar programs have their own protocol on top of UDP. For example, the tftp protocol says that for each packet that gets sent, the recipient has to send back a packet that says, \u201cI got it!\u201d (an \u201cACK\u201d packet). If the sender of the original packet gets no reply in, say, five seconds, he\u2019ll re-transmit the packet until he finally gets an ACK. This acknowledgment procedure is very important when implementing reliable SOCK_DGRAM applications.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accursed lag",
                        "tag": "em"
                    }
                ],
                "content": "For unreliable applications like games, audio, or video, you just ignore the dropped packets, or perhaps try to cleverly compensate for them. (Quake players will know the manifestation this effect by the technical term: accursed lag. The word \u201caccursed\u201d, in this case, represents any extremely profane utterance.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Why would you use an unreliable underlying protocol? Two reasons: speed and speed. It\u2019s way faster to fire-and-forget than it is to keep track of what has arrived safely and make sure it\u2019s in order and all that. If you\u2019re sending chat messages, TCP is great; if you\u2019re sending 40 positional updates per second of the players in the world, maybe it doesn\u2019t matter so much if one or two get dropped, and UDP is a good choice.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    }
                ],
                "content": "Since I just mentioned layering of protocols, it\u2019s time to talk about how networks really work, and to show some examples of how SOCK_DGRAM packets are built. Practically, you can probably skip this section. It\u2019s good background, however.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Data Encapsulation",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": ";-)",
                        "tag": "code"
                    }
                ],
                "content": "Hey, kids, it\u2019s time to learn about Data Encapsulation! This is very very important. It\u2019s so important that you might just learn about it if you take the networks course here at Chico State ;-). Basically, it says this: a packet is born, the packet is wrapped (\u201cencapsulated\u201d) in a header (and rarely a footer) by the first protocol (say, the TFTP protocol), then the whole thing (TFTP header included) is encapsulated again by the next protocol (say, UDP), then again by the next (IP), then again by the final protocol on the hardware (physical) layer (say, Ethernet).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "When another computer receives the packet, the hardware strips the Ethernet header, the kernel strips the IP and UDP headers, the TFTP program strips the TFTP header, and it finally has the data.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Layered Network Model",
                        "tag": "em"
                    }
                ],
                "content": "Now I can finally talk about the infamous Layered Network Model (aka \u201cISO/OSI\u201d). This Network Model describes a system of network functionality that has many advantages over other models. For instance, you can write sockets programs that are exactly the same without caring how the data is physically transmitted (serial, thin Ethernet, AUI, whatever) because programs on lower levels deal with it for you. The actual network hardware and topology is transparent to the socket programmer.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Without any further ado, I\u2019ll present the layers of the full-blown model. Remember this for network class exams:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The Physical Layer is the hardware (serial, Ethernet, etc.). The Application Layer is just about as far from the physical layer as you can imagine\u2014it\u2019s the place where users interact with the network.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Now, this model is so general you could probably use it as an automobile repair guide if you really wanted to. A layered model more consistent with Unix might be:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "At this point in time, you can probably see how these layers correspond to the encapsulation of the original data.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "cat",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    }
                ],
                "content": "See how much work there is in building a simple packet? Jeez! And you have to type in the packet headers yourself using \u201ccat\u201d! Just kidding. All you have to do for stream sockets is send() the data out. All you have to do for datagram sockets is encapsulate the packet in the method of your choosing and sendto() it out. The kernel builds the Transport Layer and Internet Layer on for you and the hardware does the Network Access Layer. Ah, modern technology.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "blah blah blah",
                        "tag": "em"
                    },
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc791"
                        },
                        "children": [],
                        "content": "IP RFC",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn12",
                            "id": "fnref12",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "12",
                                "tag": "sup"
                            }
                        ],
                        "content": "12",
                        "tag": "a"
                    }
                ],
                "content": "So ends our brief foray into network theory. Oh yes, I forgot to tell you everything I wanted to say about routing: nothing! That\u2019s right, I\u2019m not going to talk about it at all. The router strips the packet to the IP header, consults its routing table, blah blah blah. Check out the IP RFC12 if you really really care. If you never learn about it, well, you\u2019ll live.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Here\u2019s the part of the game where we get to talk code for a change.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But first, let\u2019s discuss more non-code! Yay! First I want to talk about IP addresses and ports for just a tad so we have that sorted out. Then we\u2019ll talk about how the sockets API stores and manipulates IP addresses and other data.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.111",
                        "tag": "code"
                    }
                ],
                "content": "In the good old days back when Ben Kenobi was still called Obi Wan Kenobi, there was a wonderful network routing system called The Internet Protocol Version 4, also called IPv4. It had addresses made up of four bytes (A.K.A. four \u201coctets\u201d), and was commonly written in \u201cdots and numbers\u201d form, like so: 192.0.2.111.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "You\u2019ve probably seen it around.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "In fact, as of this writing, virtually every site on the Internet uses IPv4.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Everyone, including Obi Wan, was happy. Things were great, until some naysayer by the name of Vint Cerf warned everyone that we were about to run out of IPv4 addresses!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://en.wikipedia.org/wiki/Vint_Cerf"
                        },
                        "children": [],
                        "content": "Vint Cerf",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn13",
                            "id": "fnref13",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "13",
                                "tag": "sup"
                            }
                        ],
                        "content": "13",
                        "tag": "a"
                    }
                ],
                "content": "(Besides warning everyone of the Coming IPv4 Apocalypse Of Doom And Gloom, Vint Cerf13 is also well-known for being The Father Of The Internet. So I really am in no position to second-guess his judgment.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Run out of addresses? How could this be? I mean, there are like billions of IP addresses in a 32-bit IPv4 address. Do we really have billions of computers out there?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Yes.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Also, in the beginning, when there were only a few computers and everyone thought a billion was an impossibly large number, some big organizations were generously allocated millions of IP addresses for their own use. (Such as Xerox, MIT, Ford, HP, IBM, GE, AT&T, and some little company called Apple, to name a few.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "In fact, if it weren\u2019t for several stopgap measures, we would have run out a long time ago.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But now we\u2019re living in an era where we\u2019re talking about every human having an IP address, every computer, every calculator, every phone, every parking meter, and (why not) every puppy dog, as well.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://en.wikipedia.org/wiki/ELIZA"
                        },
                        "children": [],
                        "content": "ELIZA",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn14",
                            "id": "fnref14",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "14",
                                "tag": "sup"
                            }
                        ],
                        "content": "14",
                        "tag": "a"
                    }
                ],
                "content": "And so, IPv6 was born. Since Vint Cerf is probably immortal (even if his physical form should pass on, heaven forbid, he is probably already existing as some kind of hyper-intelligent ELIZA14 program out in the depths of the Internet2), no one wants to have to hear him say again \u201cI told you so\u201d if we don\u2019t have enough addresses in the next version of the Internet Protocol.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What does this suggest to you?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "lot",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "79 MILLION BILLION TRILLION times as many possible addresses!",
                        "tag": "em"
                    }
                ],
                "content": "That we need a lot more addresses. That we need not just twice as many addresses, not a billion times as many, not a thousand trillion times as many, but 79 MILLION BILLION TRILLION times as many possible addresses! That\u2019ll show \u2019em!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "32",
                        "tag": "sup"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "128",
                        "tag": "sup"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "every single star in the Universe",
                        "tag": "em"
                    }
                ],
                "content": "You\u2019re saying, \u201cBeej, is that true? I have every reason to disbelieve large numbers.\u201d Well, the difference between 32 bits and 128 bits might not sound like a lot; it\u2019s only 96 more bits, right? But remember, we\u2019re talking powers here: 32 bits represents some 4 billion numbers (232), while 128 bits represents about 340 trillion trillion trillion numbers (for real, 2128). That\u2019s like a million IPv4 Internets for every single star in the Universe.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Forget this dots-and-numbers look of IPv4, too; now we\u2019ve got a hexadecimal representation, with each two-byte chunk separated by a colon, like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "That\u2019s not all! Lots of times, you\u2019ll have an IP address with lots of zeros in it, and you can compress them between two colons. And you can leave off leading zeros for each byte pair. For instance, each of these pairs of addresses are equivalent:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "::1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "loopback address",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "127.0.0.1",
                        "tag": "code"
                    }
                ],
                "content": "The address ::1 is the loopback address. It always means \u201cthis machine I\u2019m running on now\u201d. In IPv4, the loopback address is 127.0.0.1.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.33",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "::ffff:192.0.2.33",
                        "tag": "code"
                    }
                ],
                "content": "Finally, there\u2019s an IPv4-compatibility mode for IPv6 addresses that you might come across. If you want, for example, to represent the IPv4 address 192.0.2.33 as an IPv6 address, you use the following notation: \u201c::ffff:192.0.2.33\u201d.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "We\u2019re talking serious fun.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "In fact, it\u2019s such serious fun, that the Creators of IPv6 have quite cavalierly lopped off trillions and trillions of addresses for reserved use, but we have so many, frankly, who\u2019s even counting anymore? There are plenty left over for every man, woman, child, puppy, and parking meter on every planet in the galaxy. And believe me, every planet in the galaxy has parking meters. You know it\u2019s true.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "network portion",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "host portion",
                        "tag": "em"
                    }
                ],
                "content": "For organizational reasons, it\u2019s sometimes convenient to declare that \u201cthis first part of this IP address up through this bit is the network portion of the IP address, and the remainder is the host portion.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.12",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "12",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.0",
                        "tag": "code"
                    }
                ],
                "content": "For instance, with IPv4, you might have 192.0.2.12, and we could say that the first three bytes are the network and the last byte was the host. Or, put another way, we\u2019re talking about host 12 on network 192.0.2.0 (see how we zero out the byte that was the host).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "And now for more outdated information! Ready? In the Ancient Times, there were \u201cclasses\u201d of subnets, where the first one, two, or three bytes of the address was the network part. If you were lucky enough to have one byte for the network and three for the host, you could have 24 bits-worth of hosts on your network (16 million or so). That was a \u201cClass A\u201d network. On the opposite end was a \u201cClass C\u201d, with three bytes of network, and one byte of host (256 hosts, minus a couple that were reserved).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "So as you can see, there were just a few Class As, a huge pile of Class Cs, and some Class Bs in the middle.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "netmask",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.255.255.0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.12",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.12",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.255.255.0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.0",
                        "tag": "code"
                    }
                ],
                "content": "The network portion of the IP address is described by something called the netmask, which you bitwise-AND with the IP address to get the network number out of it. The netmask usually looks something like 255.255.255.0. (E.g. with that netmask, if your IP is 192.0.2.12, then your network is 192.0.2.12 AND 255.255.255.0 which gives 192.0.2.0.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.255.255.252",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ALWAYS",
                        "tag": "em"
                    }
                ],
                "content": "Unfortunately, it turned out that this wasn\u2019t fine-grained enough for the eventual needs of the Internet; we were running out of Class C networks quite quickly, and we were most definitely out of Class As, so don\u2019t even bother to ask. To remedy this, The Powers That Be allowed for the netmask to be an arbitrary number of bits, not just 8, 16, or 24. So you might have a netmask of, say 255.255.255.252, which is 30 bits of network, and 2 bits of host allowing for four hosts on the network. (Note that the netmask is ALWAYS a bunch of 1-bits followed by a bunch of 0-bits.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.192.0.0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.12/30",
                        "tag": "code"
                    }
                ],
                "content": "But it\u2019s a bit unwieldy to use a big string of numbers like 255.192.0.0 as a netmask. First of all, people don\u2019t have an intuitive idea of how many bits that is, and secondly, it\u2019s really not compact. So the New Style came along, and it\u2019s much nicer. You just put a slash after the IP address, and then follow that by the number of network bits in decimal. Like this: 192.0.2.12/30.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "2001:db8::/32",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "2001:db8:5413:4028::9db9/64",
                        "tag": "code"
                    }
                ],
                "content": "Or, for IPv6, something like this: 2001:db8::/32 or 2001:db8:5413:4028::9db9/64.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#lowlevel"
                        },
                        "children": [],
                        "content": "Layered Network Model",
                        "tag": "a"
                    }
                ],
                "content": "If you\u2019ll kindly remember, I presented you earlier with the Layered Network Model which had the Internet Layer (IP) split off from the Host-to-Host Transport Layer (TCP and UDP). Get up to speed on that before the next paragraph.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "port number",
                        "tag": "em"
                    }
                ],
                "content": "Turns out that besides an IP address (used by the IP layer), there is another address that is used by TCP (stream sockets) and, coincidentally, by UDP (datagram sockets). It is the port number. It\u2019s a 16-bit number that\u2019s like the local address for the connection.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Think of the IP address as the street address of a hotel, and the port number as the room number. That\u2019s a decent analogy; maybe later I\u2019ll come up with one involving the automobile industry.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Say you want to have a computer that handles incoming mail AND web services\u2014how do you differentiate between the two on a computer with a single IP address?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://www.iana.org/assignments/port-numbers"
                        },
                        "children": [],
                        "content": "the Big IANA Port List",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn15",
                            "id": "fnref15",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "15",
                                "tag": "sup"
                            }
                        ],
                        "content": "15",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "/etc/services",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://en.wikipedia.org/wiki/Doom_(1993_video_game)"
                        },
                        "children": [],
                        "content": "DOOM",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn16",
                            "id": "fnref16",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "16",
                                "tag": "sup"
                            }
                        ],
                        "content": "16",
                        "tag": "a"
                    }
                ],
                "content": "Well, different services on the Internet have different well-known port numbers. You can see them all in the Big IANA Port List15 or, if you\u2019re on a Unix box, in your /etc/services file. HTTP (the web) is port 80, telnet is port 23, SMTP is port 25, the game DOOM16 used port 666, etc. and so on. Ports under 1024 are often considered special, and usually require special OS privileges to use.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "And that\u2019s about it!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " By Order of the Realm! There shall be two byte orderings, hereafter to be known as Lame and Magnificent!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "I joke, but one really is better than the other. :-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "There really is no easy way to say this, so I\u2019ll just blurt it out: your computer might have been storing bytes in reverse order behind your back. I know! No one wanted to have to tell you.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "b34f",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "b3",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "4f",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://en.wikipedia.org/wiki/Wilford_Brimley"
                        },
                        "children": [],
                        "content": "Wilford Brimley",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn17",
                            "id": "fnref17",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "17",
                                "tag": "sup"
                            }
                        ],
                        "content": "17",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Big-Endian",
                        "tag": "em"
                    }
                ],
                "content": "The thing is, everyone in the Internet world has generally agreed that if you want to represent the two-byte hex number, say b34f, you\u2019ll store it in two sequential bytes b3 followed by 4f. Makes sense, and, as Wilford Brimley17 would tell you, it\u2019s the Right Thing To Do. This number, stored with the big end first, is called Big-Endian.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "few",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "b34f",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "4f",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "b3",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Little-Endian",
                        "tag": "em"
                    }
                ],
                "content": "Unfortunately, a few computers scattered here and there throughout the world, namely anything with an Intel or Intel-compatible processor, store the bytes reversed, so b34f would be stored in memory as the sequential bytes 4f followed by b3. This storage method is called Little-Endian.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Big-Endian",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Network Byte Order",
                        "tag": "em"
                    }
                ],
                "content": "But wait, I\u2019m not done with terminology yet! The more-sane Big-Endian is also called Network Byte Order because that\u2019s the order us network types like.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Host Byte Order",
                        "tag": "em"
                    }
                ],
                "content": "Your computer stores numbers in Host Byte Order. If it\u2019s an Intel 80x86, Host Byte Order is Little-Endian. If it\u2019s a Motorola 68k, Host Byte Order is Big-Endian. If it\u2019s a PowerPC, Host Byte Order is\u2026 well, it depends!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "A lot of times when you\u2019re building packets or filling out data structures you\u2019ll need to make sure your two- and four-byte numbers are in Network Byte Order. But how can you do this if you don\u2019t know the native Host Byte Order?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Good news! You just get to assume the Host Byte Order isn\u2019t right, and you always run the value through a function to set it to Network Byte Order. The function will do the magic conversion if it has to, and this way your code is portable to machines of differing endianness.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "short",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "long",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "unsigned",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "short",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htons()",
                        "tag": "code"
                    }
                ],
                "content": "All righty. There are two types of numbers that you can convert: short (two bytes) and long (four bytes). These functions work for the unsigned variations as well. Say you want to convert a short from Host Byte Order to Network Byte Order. Start with \u201ch\u201d for \u201chost\u201d, follow it with \u201cto\u201d, then \u201cn\u201d for \u201cnetwork\u201d, and \u201cs\u201d for \u201cshort\u201d: h-to-n-s, or htons() (read: \u201cHost to Network Short\u201d).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "It\u2019s almost too easy\u2026",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "stolh()",
                        "tag": "code"
                    }
                ],
                "content": "You can use every combination of \u201cn\u201d, \u201ch\u201d, \u201cs\u201d, and \u201cl\u201d you want, not counting the really stupid ones. For example, there is NOT a stolh() (\u201cShort to Long Host\u201d) function\u2014not at this party, anyway. But there are:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Basically, you\u2019ll want to convert the numbers to Network Byte Order before they go out on the wire, and convert them to Host Byte Order as they come in off the wire.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#serialization"
                        },
                        "children": [],
                        "content": "Serialization",
                        "tag": "a"
                    }
                ],
                "content": "I don\u2019t know of a 64-bit variant, sorry. And if you want to do floating point, check out the section on Serialization, far below.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Assume the numbers in this document are in Host Byte Order unless I say otherwise.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Well, we\u2019re finally here. It\u2019s time to talk about programming. In this section, I\u2019ll cover various data types used by the sockets interface, since some of them are a real bear to figure out.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "First the easy one: a socket descriptor. A socket descriptor is the following type:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    }
                ],
                "content": "Just a regular int.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Things get weird from here, so just read through and bear with me.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    }
                ],
                "content": "My First Struct\u2122\u2014struct addrinfo. This structure is a more recent invention, and is used to prep the socket address structures for subsequent use. It\u2019s also used in host name lookups, and service name lookups. That\u2019ll make more sense later when we get to actual usage, but just know for now that it\u2019s one of the first things you\u2019ll call when making a connection.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "You\u2019ll load this struct up a bit, and then call getaddrinfo(). It\u2019ll return a pointer to a new linked list of these structures filled out with all the goodies you need.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_UNSPEC",
                        "tag": "code"
                    }
                ],
                "content": "You can force it to use IPv4 or IPv6 in the ai_family field, or leave it as AF_UNSPEC to use whatever. This is cool because your code can be IP version-agnostic.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_next",
                        "tag": "code"
                    }
                ],
                "content": "Note that this is a linked list: ai_next points at the next element\u2014there could be several results for you to choose from. I\u2019d use the first result that worked, but you might have different business needs; I don\u2019t know everything, man!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "You\u2019ll see that the ai_addr field in the struct addrinfo is a pointer to a struct sockaddr. This is where we start getting into the nitty-gritty details of what\u2019s inside an IP address structure.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "will",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "You might not usually need to write to these structures; oftentimes, a call to getaddrinfo() to fill out your struct addrinfo for you is all you\u2019ll need. You will, however, have to peer inside these structs to get the values out, so I\u2019m presenting them here.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    }
                ],
                "content": "(Also, all the code written before struct addrinfo was invented we packed all this stuff by hand, so you\u2019ll see a lot of IPv4 code out in the wild that does exactly that. You know, in old versions of this guide and so on.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "Some structs are IPv4, some are IPv6, and some are both. I\u2019ll make notes of which are what.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Anyway, the struct sockaddr holds socket address information for many types of sockets.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sa_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sa_data",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sa_data",
                        "tag": "code"
                    }
                ],
                "content": "sa_family can be a variety of things, but it\u2019ll be AF_INET (IPv4) or AF_INET6 (IPv6) for everything we do in this document. sa_data contains a destination address and port number for the socket. This is rather unwieldy since you don\u2019t want to tediously pack the address in the sa_data by hand.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    }
                ],
                "content": "To deal with struct sockaddr, programmers created a parallel structure: struct sockaddr_in (\u201cin\u201d for \u201cInternet\u201d) to be used with IPv4.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "this is the important",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    }
                ],
                "content": "And this is the important bit: a pointer to a struct sockaddr_in can be cast to a pointer to a struct sockaddr and vice-versa. So even though connect() wants a struct sockaddr*, you can still use a struct sockaddr_in and cast it at the last minute!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_zero",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "memset()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sa_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_port",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Network Byte Order",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htons()",
                        "tag": "code"
                    }
                ],
                "content": "This structure makes it easy to reference elements of the socket address. Note that sin_zero (which is included to pad the structure to the length of a struct sockaddr) should be set to all zeros with the function memset(). Also, notice that sin_family corresponds to sa_family in a struct sockaddr and should be set to \u201cAF_INET\u201d. Finally, the sin_port must be in Network Byte Order (by using htons()!)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    }
                ],
                "content": "Let\u2019s dig deeper! You see the sin_addr field is a struct in_addr. What is that thing? Well, not to be overly dramatic, but it\u2019s one of the scariest unions of all time:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "used",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ina",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ina.sin_addr.s_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "#define",
                        "tag": "code"
                    }
                ],
                "content": "Whoa! Well, it used to be a union, but now those days seem to be gone. Good riddance. So if you have declared ina to be of type struct sockaddr_in, then ina.sin_addr.s_addr references the 4-byte IP address (in Network Byte Order). Note that even if your system still uses the God-awful union for struct in_addr, you can still reference the 4-byte IP address in exactly the same way as I did above (this due to #defines).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "What about IPv6? Similar structs exist for it, as well:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Note that IPv6 has an IPv6 address and a port number, just like IPv4 has an IPv4 address and a port number.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "Also note that I\u2019m not going to talk about the IPv6 flow information or Scope ID fields for the moment\u2026 this is just a starter guide. :-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Last but not least, here is another simple structure, struct sockaddr_storage that is designed to be large enough to hold both IPv4 and IPv6 structures. See, for some calls, sometimes you don\u2019t know in advance if it\u2019s going to fill out your struct sockaddr with an IPv4 or IPv6 address. So you pass in this parallel structure, very similar to struct sockaddr except larger, and then cast it to the type you need:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ss_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    }
                ],
                "content": "What\u2019s important is that you can see the address family in the ss_family field\u2014check this to see if it\u2019s AF_INET or AF_INET6 (for IPv4 or IPv6). Then you can cast it to a struct sockaddr_in or struct sockaddr_in6 if you wanna.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "long",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "<<",
                        "tag": "code"
                    }
                ],
                "content": "Fortunately for you, there are a bunch of functions that allow you to manipulate IP addresses. No need to figure them out by hand and stuff them in a long with the << operator.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in ina",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "10.12.110.57",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "2001:db8:63b3:1::3490",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_pton()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "pton",
                        "tag": "code"
                    }
                ],
                "content": "First, let\u2019s say you have a struct sockaddr_in ina, and you have an IP address \u201c10.12.110.57\u201d or \u201c2001:db8:63b3:1::3490\u201d that you want to store into it. The function you want to use, inet_pton(), converts an IP address in numbers-and-dots notation into either a struct in_addr or a struct in6_addr depending on whether you specify AF_INET or AF_INET6. (\u201cpton\u201d stands for \u201cpresentation to network\u201d\u2014you can call it \u201cprintable to network\u201d if that\u2019s easier to remember.) The conversion can be made as follows:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_addr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_aton()",
                        "tag": "code"
                    }
                ],
                "content": "(Quick note: the old way of doing things used a function called inet_addr() or another function called inet_aton(); these are now obsolete and don\u2019t work with IPv6.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_pton()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    }
                ],
                "content": "Now, the above code snippet isn\u2019t very robust because there is no error checking. See, inet_pton() returns -1 on error, or 0 if the address is messed up. So check to make sure the result is greater than 0 before using!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntop()",
                        "tag": "code"
                    }
                ],
                "content": "All right, now you can convert string IP addresses to their binary representations. What about the other way around? What if you have a struct in_addr and you want to print it in numbers-and-dots notation? (Or a struct in6_addr that you want in, uh, \u201chex-and-colons\u201d notation.) In this case, you\u2019ll want to use the function inet_ntop() (\u201cntop\u201d means \u201cnetwork to presentation\u201d\u2014you can call it \u201cnetwork to printable\u201d if that\u2019s easier to remember), like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INET_ADDRSTRLEN",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INET6_ADDRSTRLEN",
                        "tag": "code"
                    }
                ],
                "content": "When you call it, you\u2019ll pass the address type (IPv4 or IPv6), the address, a pointer to a string to hold the result, and the maximum length of that string. (Two macros conveniently hold the size of the string you\u2019ll need to hold the largest IPv4 or IPv6 address: INET_ADDRSTRLEN and INET6_ADDRSTRLEN.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntoa()",
                        "tag": "code"
                    }
                ],
                "content": "(Another quick note to mention once again the old way of doing things: the historical function to do this conversion was called inet_ntoa(). It\u2019s also obsolete and won\u2019t work with IPv6.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "www.example.com",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Lastly, these functions only work with numeric IP addresses\u2014they won\u2019t do any nameserver DNS lookup on a hostname, like \u201cwww.example.com\u201d. You will use getaddrinfo() to do that, as you\u2019ll see later on.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Network Address Translation",
                        "tag": "em"
                    }
                ],
                "content": " Lots of places have a firewall that hides the network from the rest of the world for their own protection. And often times, the firewall translates \u201cinternal\u201d IP addresses to \u201cexternal\u201d (that everyone else in the world knows) IP addresses using a process called Network Address Translation, or NAT.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Are you getting nervous yet? \u201cWhere\u2019s he going with all this weird stuff?\u201d",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Well, relax and buy yourself a non-alcoholic (or alcoholic) drink, because as a beginner, you don\u2019t even have to worry about NAT, since it\u2019s done for you transparently. But I wanted to talk about the network behind the firewall in case you started getting confused by the network numbers you were seeing.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "For instance, I have a firewall at home. I have two static IPv4 addresses allocated to me by the DSL company, and yet I have seven computers on the network. How is this possible? Two computers can\u2019t share the same IP address, or else the data wouldn\u2019t know which one to go to!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The answer is: they don\u2019t share the same IP addresses. They are on a private network with 24 million IP addresses allocated to it. They are all just for me. Well, all for me as far as anyone else is concerned. Here\u2019s what\u2019s happening:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "If I log into a remote computer, it tells me I\u2019m logged in from 192.0.2.33 which is the public IP address my ISP has provided to me. But if I ask my local computer what its IP address is, it says 10.0.0.5. Who is translating the IP address from one to the other? That\u2019s right, the firewall! It\u2019s doing NAT!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "10.x.x.x",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc1918"
                        },
                        "children": [],
                        "content": "RFC 1918",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn18",
                            "id": "fnref18",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "18",
                                "tag": "sup"
                            }
                        ],
                        "content": "18",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "10.x.x.x",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.168.x.x",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "x",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "172.y.x.x",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "y",
                        "tag": "code"
                    }
                ],
                "content": "10.x.x.x is one of a few reserved networks that are only to be used either on fully disconnected networks, or on networks that are behind firewalls. The details of which private network numbers are available for you to use are outlined in RFC 191818, but some common ones you\u2019ll see are 10.x.x.x and 192.168.x.x, where x is 0-255, generally. Less common is 172.y.x.x, where y goes between 16 and 31.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "need",
                        "tag": "em"
                    }
                ],
                "content": "Networks behind a NATing firewall don\u2019t need to be on one of these reserved networks, but they commonly are.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.33",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.x",
                        "tag": "code"
                    }
                ],
                "content": "(Fun fact! My external IP address isn\u2019t really 192.0.2.33. The 192.0.2.x network is reserved for make-believe \u201creal\u201d IP addresses to be used in documentation, just like this guide! Wowzers!)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fdXX:",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fcXX:",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc4193"
                        },
                        "children": [],
                        "content": "RFC 4193",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn19",
                            "id": "fnref19",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "19",
                                "tag": "sup"
                            }
                        ],
                        "content": "19",
                        "tag": "a"
                    }
                ],
                "content": " IPv6 has private networks, too, in a sense. They\u2019ll start with fdXX: (or maybe in the future fcXX:), as per RFC 419319. NAT and IPv6 don\u2019t generally mix, however (unless you\u2019re doing the IPv6 to IPv4 gateway thing which is beyond the scope of this document)\u2014in theory you\u2019ll have so many addresses at your disposal that you won\u2019t need to use NAT any longer. But if you want to allocate addresses for yourself on a network that won\u2019t route outside, this is how to do it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But I just want to know what to change in my code to get it going with IPv6! Tell me now!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Ok! Ok!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Almost everything in here is something I\u2019ve gone over, above, but it\u2019s the short version for the impatient. (Of course, there is more than this, but this is what applies to the guide.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#structs"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "First of all, try to use getaddrinfo() to get all the struct sockaddr info, instead of packing the structures by hand. This will keep you IP version-agnostic, and will eliminate many of the subsequent steps.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Any place that you find you\u2019re hard-coding anything related to the IP version, try to wrap up in a helper function.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    }
                ],
                "content": "Change AF_INET to AF_INET6.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET6",
                        "tag": "code"
                    }
                ],
                "content": "Change PF_INET to PF_INET6.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_ANY",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "in6addr_any",
                        "tag": "code"
                    }
                ],
                "content": "Change INADDR_ANY assignments to in6addr_any assignments, which are slightly different:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "IN6ADDR_ANY_INIT",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    }
                ],
                "content": "Also, the value IN6ADDR_ANY_INIT can be used as an initializer when the struct in6_addr is declared, like so:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#structs"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct",
                                "tag": "code"
                            }
                        ],
                        "content": "structs",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin6_zero",
                        "tag": "code"
                    }
                ],
                "content": "Instead of struct sockaddr_in use struct sockaddr_in6, being sure to add \u201c6\u201d to the fields as appropriate (see structs, above). There is no sin6_zero field.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#structs"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct",
                                "tag": "code"
                            }
                        ],
                        "content": "structs",
                        "tag": "a"
                    }
                ],
                "content": "Instead of struct in_addr use struct in6_addr, being sure to add \u201c6\u201d to the fields as appropriate (see structs, above).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_aton()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_addr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_pton()",
                        "tag": "code"
                    }
                ],
                "content": "Instead of inet_aton() or inet_addr(), use inet_pton().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntoa()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntop()",
                        "tag": "code"
                    }
                ],
                "content": "Instead of inet_ntoa(), use inet_ntop().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Instead of gethostbyname(), use the superior getaddrinfo().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getnameinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    }
                ],
                "content": "Instead of gethostbyaddr(), use the superior getnameinfo() (although gethostbyaddr() can still work with IPv6).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_BROADCAST",
                        "tag": "code"
                    }
                ],
                "content": "INADDR_BROADCAST no longer works. Use IPv6 multicast instead.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Et voila",
                        "tag": "em"
                    }
                ],
                "content": "Et voila!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This is the section where we get into the system calls (and other library calls) that allow you to access the network functionality of a Unix box, or any box that supports the sockets API for that matter (BSD, Windows, Linux, Mac, what-have-you.) When you call one of these functions, the kernel takes over and does all the work for you automagically.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "exactly",
                        "tag": "em"
                    }
                ],
                "content": "The place most people get stuck around here is what order to call these things in. In that, the man pages are no use, as you\u2019ve probably discovered. Well, to help with that dreadful situation, I\u2019ve tried to lay out the system calls in the following sections in exactly (approximately) the same order that you\u2019ll need to call them in your programs.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "That, coupled with a few pieces of sample code here and there, some milk and cookies (which I fear you will have to supply yourself), and some raw guts and courage, and you\u2019ll be beaming data around the Internet like the Son of Jon Postel!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "(Please note that for brevity, many code snippets below do not include necessary error checking. And they very commonly assume that the result from calls to getaddrinfo() succeed and return a valid entry in the linked list. Both of these situations are properly addressed in the stand-alone programs, though, so use those as a model.)",
                        "tag": "em"
                    }
                ],
                "content": "(Please note that for brevity, many code snippets below do not include necessary error checking. And they very commonly assume that the result from calls to getaddrinfo() succeed and return a valid entry in the linked list. Both of these situations are properly addressed in the stand-alone programs, though, so use those as a model.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": " This is a real workhorse of a function with a lot of options, but usage is actually pretty simple. It helps set up the structs you need later on.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    }
                ],
                "content": "A tiny bit of history: it used to be that you would use a function called gethostbyname() to do DNS lookups. Then you\u2019d load that information by hand into a struct sockaddr_in, and use that in your calls.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "This is no longer necessary, thankfully. (Nor is it desirable, if you want to write code that works for both IPv4 and IPv6!) In these modern times, you now have the function getaddrinfo() that does all kinds of good stuff for you, including DNS and service name lookups, and fills out the structs you need, besides!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Let\u2019s take a look!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "res",
                        "tag": "code"
                    }
                ],
                "content": "You give this function three input parameters, and it gives you a pointer to a linked-list, res, of results.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "node",
                        "tag": "code"
                    }
                ],
                "content": "The node parameter is the host name to connect to, or an IP address.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "service",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://www.iana.org/assignments/port-numbers"
                        },
                        "children": [],
                        "content": "The IANA Port List",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn20",
                            "id": "fnref20",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "20",
                                "tag": "sup"
                            }
                        ],
                        "content": "20",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "/etc/services",
                        "tag": "code"
                    }
                ],
                "content": "Next is the parameter service, which can be a port number, like \u201c80\u201d, or the name of a particular service (found in The IANA Port List20 or the /etc/services file on your Unix machine) like \u201chttp\u201d or \u201cftp\u201d or \u201ctelnet\u201d or \u201csmtp\u201d or whatever.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hints",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    }
                ],
                "content": "Finally, the hints parameter points to a struct addrinfo that you\u2019ve already filled out with relevant information.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Here\u2019s a sample call if you\u2019re a server who wants to listen on your host\u2019s IP address, port 3490. Note that this doesn\u2019t actually do any listening or network setup; it merely sets up structures we\u2019ll use later:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_UNSPEC",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    }
                ],
                "content": "Notice that I set the ai_family to AF_UNSPEC, thereby saying that I don\u2019t care if we use IPv4 or IPv6. You can set it to AF_INET or AF_INET6 if you want one or the other specifically.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    }
                ],
                "content": "Also, you\u2019ll see the AI_PASSIVE flag in there; this tells getaddrinfo() to assign the address of my local host to the socket structures. This is nice because then you don\u2019t have to hardcode it. (Or you can put a specific address in as the first parameter to getaddrinfo() where I currently have NULL, up there.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gai_strerror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "servinfo",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Then we make the call. If there\u2019s an error (getaddrinfo() returns non-zero), we can print it out using the function gai_strerror(), as you see. If everything works properly, though, servinfo will point to a linked list of struct addrinfos, each of which contains a struct sockaddr of some kind that we can use later! Nifty!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "freeaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Finally, when we\u2019re eventually all done with the linked list that getaddrinfo() so graciously allocated for us, we can (and should) free it all up with a call to freeaddrinfo().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Here\u2019s a sample call if you\u2019re a client who wants to connect to a particular server, say \u201cwww.example.net\u201d port 3490. Again, this doesn\u2019t actually connect, but it sets up the structures we\u2019ll use later:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "servinfo",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/showip.c"
                        },
                        "children": [],
                        "content": "This short program",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn21",
                            "id": "fnref21",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "21",
                                "tag": "sup"
                            }
                        ],
                        "content": "21",
                        "tag": "a"
                    }
                ],
                "content": "I keep saying that servinfo is a linked list with all kinds of address information. Let\u2019s write a quick demo program to show off this information. This short program21 will print the IP addresses for whatever host you specify on the command line:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "res",
                        "tag": "code"
                    }
                ],
                "content": "As you see, the code calls getaddrinfo() on whatever you pass on the command line, that fills out the linked list pointed to by res, and then we can iterate over the list and print stuff out or do whatever.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "(There\u2019s a little bit of ugliness there where we have to dig into the different types of struct sockaddrs depending on the IP version. Sorry about that! I\u2019m not sure of a better way around it.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Sample run! Everyone loves screenshots:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Now that we have that under control, we\u2019ll use the results we get from getaddrinfo() to pass to other socket functions and, at long last, get our network connection established! Keep reading!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    }
                ],
                "content": "I guess I can put it off no longer\u2014I have to talk about the socket() system call. Here\u2019s the breakdown:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But what are these arguments? They allow you to say what kind of socket you want (IPv4 or IPv6, stream or datagram, and TCP or UDP).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "domain",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "type",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "protocol",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "type",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getprotobyname()",
                        "tag": "code"
                    }
                ],
                "content": "It used to be people would hardcode these values, and you can absolutely still do that. (domain is PF_INET or PF_INET6, type is SOCK_STREAM or SOCK_DGRAM, and protocol can be set to 0 to choose the proper protocol for the given type. Or you can call getprotobyname() to look up the protocol you want, \u201ctcp\u201d or \u201cudp\u201d.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "PF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    }
                ],
                "content": "(This PF_INET thing is a close relative of the AF_INET that you can use when initializing the sin_family field in your struct sockaddr_in. In fact, they\u2019re so closely related that they actually have the same value, and many programmers will call socket() and pass AF_INET as the first argument instead of PF_INET. Now, get some milk and cookies, because it\u2019s time for a story. Once upon a time, a long time ago, it was thought that maybe an address family (what the \u201cAF\u201d in \u201cAF_INET\u201d stands for) might support several protocols that were referred to by their protocol family (what the \u201cPF\u201d in \u201cPF_INET\u201d stands for). That didn\u2019t happen. And they all lived happily ever after, The End. So the most correct thing to do is to use AF_INET in your struct sockaddr_in and PF_INET in your call to socket().)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    }
                ],
                "content": "Anyway, enough of that. What you really want to do is use the values from the results of the call to getaddrinfo(), and feed them into socket() directly like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket descriptor",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#errnoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "errno",
                                "tag": "code"
                            }
                        ],
                        "content": "errno",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "socket() simply returns to you a socket descriptor that you can use in later system calls, or -1 on error. The global variable errno is set to the error\u2019s value (see the errno man page for more details, and a quick note on using errno in multithreaded programs).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Fine, fine, fine, but what good is this socket? The answer is that it\u2019s really no good by itself, and you need to read on and make more system calls for it to make any sense.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": " Once you have a socket, you might have to associate that socket with a port on your local machine. (This is commonly done if you\u2019re going to listen() for incoming connections on a specific port\u2014multiplayer network games do this when they tell you to \u201cconnect to 192.168.5.10 port 3490\u201d.) The port number is used by the kernel to match an incoming packet to a certain process\u2019s socket descriptor. If you\u2019re going to only be doing a connect() (because you\u2019re the client, not the server), this is probably unnecessary. Read it anyway, just for kicks.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "Here is the synopsis for the bind() system call:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "my_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addrlen",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the socket file descriptor returned by socket(). my_addr is a pointer to a struct sockaddr that contains information about your address, namely, port and IP address. addrlen is the length in bytes of that address.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Whew. That\u2019s a bit to absorb in one chunk. Let\u2019s have an example that binds the socket to the host the program is running on, port 3490:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "By using the AI_PASSIVE flag, I\u2019m telling the program to bind to the IP of the host it\u2019s running on. If you want to bind to a specific local IP address, drop the AI_PASSIVE and put an IP address in for the first argument to getaddrinfo().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "bind() also returns -1 on error and sets errno to the error\u2019s value.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Lots of old code manually packs the struct sockaddr_in before calling bind(). Obviously this is IPv4-specific, but there\u2019s really nothing stopping you from doing the same thing with IPv6, except that using getaddrinfo() is going to be easier, generally. Anyway, the old code looks something like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_ANY",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_ANY",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "in6addr_any",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "IN6ADDR_ANY_INIT",
                        "tag": "code"
                    }
                ],
                "content": "In the above code, you could also assign INADDR_ANY to the s_addr field if you wanted to bind to your local IP address (like the AI_PASSIVE flag, above). The IPv6 version of INADDR_ANY is a global variable in6addr_any that is assigned into the sin6_addr field of your struct sockaddr_in6. (There is also a macro IN6ADDR_ANY_INIT that you can use in a variable initializer.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "Another thing to watch out for when calling bind(): don\u2019t go underboard with your port numbers. All ports below 1024 are RESERVED (unless you\u2019re the superuser)! You can have any port number above that, right up to 65535 (provided they aren\u2019t already being used by another program).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "Sometimes, you might notice, you try to rerun a server and bind() fails, claiming \u201cAddress already in use.\u201d What does that mean? Well, a little bit of a socket that was connected is still hanging around in the kernel, and it\u2019s hogging the port. You can either wait for it to clear (a minute or so), or add code to your program allowing it to reuse the port, like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": " One small extra final note about bind(): there are times when you won\u2019t absolutely have to call it. If you are connect()ing to a remote machine and you don\u2019t care what your local port is (as is the case with telnet where you only care about the remote port), you can simply call connect(), it\u2019ll check to see if the socket is unbound, and will bind() it to an unused local port if necessary.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "TRON",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "10.12.110.57",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "23",
                        "tag": "code"
                    }
                ],
                "content": " Let\u2019s just pretend for a few minutes that you\u2019re a telnet application. Your user commands you (just like in the movie TRON) to get a socket file descriptor. You comply and call socket(). Next, the user tells you to connect to \u201c10.12.110.57\u201d on port \u201c23\u201d (the standard telnet port). Yow! What do you do now?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "Lucky for you, program, you\u2019re now perusing the section on connect()\u2014how to connect to a remote host. So read furiously onward! No time to lose!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "The connect() call is as follows:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "serv_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addrlen",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is our friendly neighborhood socket file descriptor, as returned by the socket() call, serv_addr is a struct sockaddr containing the destination port and IP address, and addrlen is the length in bytes of the server address structure.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "All of this information can be gleaned from the results of the getaddrinfo() call, which rocks.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "www.example.com",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "3490",
                        "tag": "code"
                    }
                ],
                "content": "Is this starting to make more sense? I can\u2019t hear you from here, so I\u2019ll just have to hope that it is. Let\u2019s have an example where we make a socket connection to \u201cwww.example.com\u201d, port 3490:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#bind"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "bind() section",
                        "tag": "a"
                    }
                ],
                "content": "Again, old-school programs filled out their own struct sockaddr_ins to pass to connect(). You can do that if you want to. See the similar note in the bind() section, above.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Be sure to check the return value from connect()\u2014it\u2019ll return -1 on error and set the variable errno.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "Also, notice that we didn\u2019t call bind(). Basically, we don\u2019t care about our local port number; we only care where we\u2019re going (the remote port). The kernel will choose a local port for us, and the site we connect to will automatically get this information from us. No worries.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": " OK, time for a change of pace. What if you don\u2019t want to connect to a remote host. Say, just for kicks, that you want to wait for incoming connections and handle them in some way. The process is two step: first you listen(), then you accept() (see below).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    }
                ],
                "content": "The listen() call is fairly simple, but requires a bit of explanation:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "backlog",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "5",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "10",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the usual socket file descriptor from the socket() system call. backlog is the number of connections allowed on the incoming queue. What does that mean? Well, incoming connections are going to wait in this queue until you accept() them (see below) and this is the limit on how many can queue up. Most systems silently limit this number to about 20; you can probably get away with setting it to 5 or 10.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Again, as per usual, listen() returns -1 and sets errno on error.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    }
                ],
                "content": "Well, as you can probably imagine, we need to call bind() before we call listen() so that the server is running on a specific port. (You have to be able to tell your buddies which port to connect to!) So if you\u2019re going to be listening for incoming connections, the sequence of system calls you\u2019ll make is:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "I\u2019ll just leave that in the place of sample code, since it\u2019s fairly self-explanatory. (The code in the accept() section, below, is more complete.) The really tricky part of this whole sha-bang is the call to accept().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "brand new socket file descriptor",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "two socket file descriptors",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": " Get ready\u2014the accept() call is kinda weird! What\u2019s going to happen is this: someone far far away will try to connect() to your machine on a port that you are listen()ing on. Their connection will be queued up waiting to be accept()ed.\u00a0You call accept() and you tell it to get the pending connection. It\u2019ll return to you a brand new socket file descriptor to use for this single connection! That\u2019s right, suddenly you have two socket file descriptors for the price of one! The original one is still listening for more new connections, and the newly created one is finally ready to send() and recv(). We\u2019re there!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The call is as follows:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addrlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof(struct sockaddr_storage)",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addrlen",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the listen()ing socket descriptor. Easy enough. addr will usually be a pointer to a local struct sockaddr_storage. This is where the information about the incoming connection will go (and with it you can determine which host is calling you from which port). addrlen is a local integer variable that should be set to sizeof(struct sockaddr_storage) before its address is passed to accept(). accept() will not put more than that many bytes into addr. If it puts fewer in, it\u2019ll change the value of addrlen to reflect that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Guess what? accept() returns -1 and sets errno if an error occurs. Betcha didn\u2019t figure that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Like before, this is a bunch to absorb in one chunk, so here\u2019s a sample code fragment for your perusal:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "new_fd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    }
                ],
                "content": "Again, note that we will use the socket descriptor new_fd for all send() and recv() calls. If you\u2019re only getting one single connection ever, you can close() the listening sockfd in order to prevent more incoming connections on the same port, if you so desire.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#sendtorecv"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "sendto()",
                                "tag": "code"
                            },
                            {
                                "attributes": {},
                                "children": [],
                                "content": "recvfrom()",
                                "tag": "code"
                            }
                        ],
                        "content": "sendto() and recvfrom()",
                        "tag": "a"
                    }
                ],
                "content": "These two functions are for communicating over stream sockets or connected datagram sockets. If you want to use regular unconnected datagram sockets, you\u2019ll need to see the section on sendto() and recvfrom(), below.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": " The send() call:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "msg",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "flags",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the socket descriptor you want to send data to (whether it\u2019s the one returned by socket() or the one you got with accept()). msg is a pointer to the data you want to send, and len is the length of that data in bytes. Just set flags to 0. (See the send() man page for more information concerning flags.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Some sample code might be:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "this might be less than the number you told it to send!",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "probably",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "send() returns the number of bytes actually sent out\u2014this might be less than the number you told it to send! See, sometimes you tell it to send a whole gob of data and it just can\u2019t handle it. It\u2019ll fire off as much of the data as it can, and trust you to send the rest later. Remember, if the value returned by send() doesn\u2019t match the value in len, it\u2019s up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will probably manage to send the whole thing all in one go. Again, -1 is returned on error, and errno is set to the error number.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": " The recv() call is similar in many respects:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "buf",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "flags",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the socket descriptor to read from, buf is the buffer to read the information into, len is the maximum length of the buffer, and flags can again be set to 0. (See the recv() man page for flag information.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "recv() returns the number of bytes actually read into the buffer, or -1 on error (with errno set, accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Wait! recv() can return 0. This can mean only one thing: the remote side has closed the connection on you! A return value of 0 is recv()\u2019s way of letting you know this has occurred.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "There, that was easy, wasn\u2019t it? You can now pass data back and forth on stream sockets! Whee! You\u2019re a Unix Network Programmer!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " \u201cThis is all fine and dandy,\u201d I hear you saying, \u201cbut where does this leave me with unconnected datagram sockets?\u201d No problemo, amigo. We have just the thing.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Since datagram sockets aren\u2019t connected to a remote host, guess which piece of information we need to give before we send a packet? That\u2019s right! The destination address! Here\u2019s the scoop:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "to",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tolen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof *to",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof(struct sockaddr_storage)",
                        "tag": "code"
                    }
                ],
                "content": "As you can see, this call is basically the same as the call to send() with the addition of two other pieces of information. to is a pointer to a struct sockaddr (which will probably be another struct sockaddr_in or struct sockaddr_in6 or struct sockaddr_storage that you cast at the last minute) which contains the destination IP address and port. tolen, an int deep-down, can simply be set to sizeof *to or sizeof(struct sockaddr_storage).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": "To get your hands on the destination address structure, you\u2019ll probably either get it from getaddrinfo(), or from recvfrom(), below, or you\u2019ll fill it out by hand.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    }
                ],
                "content": "Just like with send(), sendto() returns the number of bytes actually sent (which, again, might be less than the number of bytes you told it to send!), or -1 on error.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": "Equally similar are recv() and recvfrom(). The synopsis of recvfrom() is:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "from",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fromlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof *from",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof(struct sockaddr_storage)",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fromlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "from",
                        "tag": "code"
                    }
                ],
                "content": "Again, this is just like recv() with the addition of a couple fields. from is a pointer to a local struct sockaddr_storage that will be filled with the IP address and port of the originating machine. fromlen is a pointer to a local int that should be initialized to sizeof *from or sizeof(struct sockaddr_storage). When the function returns, fromlen will contain the length of the address actually stored in from.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "recvfrom() returns the number of bytes received, or -1 on error (with errno set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    }
                ],
                "content": "So, here\u2019s a question: why do we use struct sockaddr_storage as the socket type? Why not struct sockaddr_in? Because, you see, we want to not tie ourselves down to IPv4 or IPv6. So we use the generic struct sockaddr_storage which we know will be big enough for either.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "(So\u2026 here\u2019s another question: why isn\u2019t struct sockaddr itself big enough for any address? We even cast the general-purpose struct sockaddr_storage to the general-purpose struct sockaddr! Seems extraneous and redundant, huh. The answer is, it just isn\u2019t big enough, and I\u2019d guess that changing it at this point would be Problematic. So they made a new one.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Remember, if you connect() a datagram socket, you can then simply use send() and recv() for all your transactions. The socket itself is still a datagram socket and the packets still use UDP, but the socket interface will automatically add the destination and source information for you.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "Whew! You\u2019ve been send()ing and recv()ing data all day long, and you\u2019ve had it. You\u2019re ready to close the connection on your socket descriptor. This is easy. You can just use the regular Unix file descriptor close() function:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This will prevent any more reads and writes to the socket. Anyone attempting to read or write the socket on the remote end will receive an error.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "shutdown()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "Just in case you want a little more control over how the socket closes, you can use the shutdown() function. It allows you to cut off communication in a certain direction, or both ways (just like close() does). Synopsis:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "how",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the socket file descriptor you want to shutdown, and how is one of the following:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "shutdown()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "shutdown() returns 0 on success, and -1 on error (with errno set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "shutdown()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "If you deign to use shutdown() on unconnected datagram sockets, it will simply make the socket unavailable for further send() and recv() calls (remember that you can use these if you connect() your datagram socket).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "shutdown()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "It\u2019s important to note that shutdown() doesn\u2019t actually close the file descriptor\u2014it just changes its usability. To free a socket descriptor, you need to use close().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Nothing to it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "closesocket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "(Except to remember that if you\u2019re using Windows and Winsock that you should call closesocket() instead of close().)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " This function is so easy.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "It\u2019s so easy, I almost didn\u2019t give it its own section. But here it is anyway.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getpeername()",
                        "tag": "code"
                    }
                ],
                "content": "The function getpeername() will tell you who is at the other end of a connected stream socket. The synopsis:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addrlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof *addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof(struct sockaddr)",
                        "tag": "code"
                    }
                ],
                "content": "sockfd is the descriptor of the connected stream socket, addr is a pointer to a struct sockaddr (or a struct sockaddr_in) that will hold the information about the other side of the connection, and addrlen is a pointer to an int, that should be initialized to sizeof *addr or sizeof(struct sockaddr).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "The function returns -1 on error and sets errno accordingly.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntop()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getnameinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc1413"
                        },
                        "children": [],
                        "content": "RFC 1413",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn22",
                            "id": "fnref22",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "22",
                                "tag": "sup"
                            }
                        ],
                        "content": "22",
                        "tag": "a"
                    }
                ],
                "content": "Once you have their address, you can use inet_ntop(), getnameinfo(), or gethostbyaddr() to print or get more information. No, you can\u2019t get their login name. (Ok, ok. If the other computer is running an ident daemon, this is possible. This, however, is beyond the scope of this document. Check out RFC 141322 for more info.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getpeername()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": " Even easier than getpeername() is the function gethostname(). It returns the name of the computer that your program is running on. The name can then be used by getaddrinfo(), above, to determine the IP address of your local machine.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What could be more fun? I could think of a few things, but they don\u2019t pertain to socket programming. Anyway, here\u2019s the breakdown:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hostname",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "size",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hostname",
                        "tag": "code"
                    }
                ],
                "content": "The arguments are simple: hostname is a pointer to an array of chars that will contain the hostname upon the function\u2019s return, and size is the length in bytes of the hostname array.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "The function returns 0 on successful completion, and -1 on error, setting errno as usual.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnetd",
                        "tag": "code"
                    }
                ],
                "content": "It\u2019s a client-server world, baby. Just about everything on the network deals with client processes talking to server processes and vice-versa. Take telnet, for instance. When you connect to a remote host on port 23 with telnet (the client), a program on that host (called telnetd, the server) springs to life. It handles the incoming telnet connection, sets you up with a login prompt, etc.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The exchange of information between client and server is summarized in the above diagram.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnetd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ftp",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ftpd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Firefox",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Apache",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ftp",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ftpd",
                        "tag": "code"
                    }
                ],
                "content": "Note that the client-server pair can speak SOCK_STREAM, SOCK_DGRAM, or anything else (as long as they\u2019re speaking the same thing). Some good examples of client-server pairs are telnet/telnetd, ftp/ftpd, or Firefox/Apache. Every time you use ftp, there\u2019s a remote program, ftpd, that serves you.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    }
                ],
                "content": "Often, there will only be one server on a machine, and that server will handle multiple clients using fork(). The basic routine is: server will wait for a connection, accept() it, and fork() a child process to handle it. This is what our sample server does in the next section.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Hello, world!",
                        "tag": "code"
                    }
                ],
                "content": "All this server does is send the string \u201cHello, world!\u201d out over a stream connection. All you need to do to test this server is run it in one window, and telnet to it from another with:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "remotehostname",
                        "tag": "code"
                    }
                ],
                "content": "where remotehostname is the name of the machine you\u2019re running it on.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/server.c"
                        },
                        "children": [],
                        "content": "The server code",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn23",
                            "id": "fnref23",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "23",
                                "tag": "sup"
                            }
                        ],
                        "content": "23",
                        "tag": "a"
                    }
                ],
                "content": "The server code23:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "main()",
                        "tag": "code"
                    }
                ],
                "content": "In case you\u2019re curious, I have the code in one big main() function for (I feel) syntactic clarity. Feel free to split it into smaller functions if it makes you feel better.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sigaction()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    }
                ],
                "content": "(Also, this whole sigaction() thing might be new to you\u2014that\u2019s OK. The code that\u2019s there is responsible for reaping zombie processes that appear as the fork()ed child processes exit. If you make lots of zombies and don\u2019t reap them, your system administrator will become agitated.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "You can get the data from this server by using the client listed in the next section.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This guy\u2019s even easier than the server. All this client does is connect to the host you specify on the command line, port 3490. It gets the string that the server sends.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/client.c"
                        },
                        "children": [],
                        "content": "The client source",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn24",
                            "id": "fnref24",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "24",
                                "tag": "sup"
                            }
                        ],
                        "content": "24",
                        "tag": "a"
                    }
                ],
                "content": "The client source24:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "Notice that if you don\u2019t run the server before you run the client, connect() returns \u201cConnection refused\u201d. Very useful.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker.c",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener.c",
                        "tag": "code"
                    }
                ],
                "content": "We\u2019ve already covered the basics of UDP datagram sockets with our discussion of sendto() and recvfrom(), above, so I\u2019ll just present a couple of sample programs: talker.c and listener.c.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker",
                        "tag": "code"
                    }
                ],
                "content": "listener sits on a machine waiting for an incoming packet on port 4950. talker sends a packet to that port, on the specified machine, that contains whatever the user enters on the command line.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "Because datagram sockets are connectionless and just fire packets off into the ether with callous disregard for success, we are going to tell the client and server to use specifically IPv6. This way we avoid the situation where the server is listening on IPv6 and the client sends on IPv4; the data simply would not be received. (In our connected TCP stream sockets world, we might still have the mismatch, but the error on connect() for one address family would cause us to retry for the other.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/listener.c"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "listener.c",
                                "tag": "code"
                            }
                        ],
                        "content": "source for listener.c",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn25",
                            "id": "fnref25",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "25",
                                "tag": "sup"
                            }
                        ],
                        "content": "25",
                        "tag": "a"
                    }
                ],
                "content": "Here is the source for listener.c25:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "Notice that in our call to getaddrinfo() we\u2019re finally using SOCK_DGRAM. Also, note that there\u2019s no need to listen() or accept(). This is one of the perks of using unconnected datagram sockets!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/talker.c"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "talker.c",
                                "tag": "code"
                            }
                        ],
                        "content": "source for talker.c",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn26",
                            "id": "fnref26",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "26",
                                "tag": "sup"
                            }
                        ],
                        "content": "26",
                        "tag": "a"
                    }
                ],
                "content": "Next comes the source for talker.c26:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker",
                        "tag": "code"
                    }
                ],
                "content": "And that\u2019s all there is to it! Run listener on some machine, then run talker on another. Watch them communicate! Fun G-rated excitement for the entire nuclear family!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": "You don\u2019t even have to run the server this time! You can run talker by itself, and it just happily fires packets off into the ether where they disappear if no one is ready with a recvfrom() on the other side. Remember: data sent using UDP datagram sockets isn\u2019t guaranteed to arrive!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Except for one more tiny detail that I\u2019ve mentioned many times in the past: connected datagram sockets. I need to talk about this here, since we\u2019re in the datagram section of the document. Let\u2019s say that talker calls connect() and specifies the listener\u2019s address. From that point on, talker may only send to and receive from the address specified by connect(). For this reason, you don\u2019t have to use sendto() and recvfrom(); you can simply use send() and recv().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "really",
                        "tag": "em"
                    }
                ],
                "content": "These aren\u2019t really advanced, but they\u2019re getting out of the more basic levels we\u2019ve already covered. In fact, if you\u2019ve gotten this far, you should consider yourself fairly accomplished in the basics of Unix network programming! Congratulations!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "So here we go into the brave new world of some of the more esoteric things you might want to learn about sockets. Have at it!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": "Blocking. You\u2019ve heard about it\u2014now what the heck is it? In a nutshell, \u201cblock\u201d is techie jargon for \u201csleep\u201d. You probably noticed that when you run listener, above, it just sits there until a packet arrives. What happened is that it called recvfrom(), there was no data, and so recvfrom() is said to \u201cblock\u201d (that is, sleep there) until some data arrives.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fcntl()",
                        "tag": "code"
                    }
                ],
                "content": "Lots of functions block. accept() blocks. All the recv() functions block. The reason they can do this is because they\u2019re allowed to. When you first create the socket descriptor with socket(), the kernel sets it to blocking. If you don\u2019t want a socket to be blocking, you have to make a call to fcntl():",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EAGAIN",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EWOULDBLOCK",
                        "tag": "code"
                    }
                ],
                "content": "By setting a socket to non-blocking, you can effectively \u201cpoll\u201d the socket for information. If you try to read from a non-blocking socket and there\u2019s no data there, it\u2019s not allowed to block\u2014it will return -1 and errno will be set to EAGAIN or EWOULDBLOCK.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EAGAIN",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "or",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EWOULDBLOCK",
                        "tag": "code"
                    }
                ],
                "content": "(Wait\u2014it can return EAGAIN or EWOULDBLOCK? Which do you check for? The specification doesn\u2019t actually specify which your system will return, so for portability, check them both.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "Generally speaking, however, this type of polling is a bad idea. If you put your program in a busy-wait looking for data on the socket, you\u2019ll suck up CPU time like it was going out of style. A more elegant solution for checking to see if there\u2019s data waiting to be read comes in the following section on poll().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bunch",
                        "tag": "em"
                    }
                ],
                "content": "What you really want to be able to do is somehow monitor a bunch of sockets at once and then handle the ones that have data ready. This way you don\u2019t have to continuously poll all those sockets to see which are ready to read.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "poll()",
                                "tag": "code"
                            },
                            {
                                "attributes": {
                                    "href": "https://libevent.org/"
                                },
                                "children": [],
                                "content": "libevent",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn27",
                                    "id": "fnref27",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "27",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "27",
                                "tag": "a"
                            }
                        ],
                        "content": "A word of warning: poll() is horribly slow when it comes to giant numbers of connections. In those circumstances, you\u2019ll get better performance out of an event library such as libevent27 that attempts to use the fastest possible method availabile on your system.",
                        "tag": "em"
                    }
                ],
                "content": "A word of warning: poll() is horribly slow when it comes to giant numbers of connections. In those circumstances, you\u2019ll get better performance out of an event library such as libevent27 that attempts to use the fastest possible method availabile on your system.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "So how can you avoid polling? Not slightly ironically, you can avoid polling by using the poll() system call. In a nutshell, we\u2019re going to ask the operating system to do all the dirty work for us, and just let us know when some data is ready to read on which sockets. In the meantime, our process can go to sleep, saving system resources.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct pollfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "The general gameplan is to keep an array of struct pollfds with information about which socket descriptors we want to monitor, and what kind of events we want to monitor for. The OS will block on the poll() call until one of those events occurs (e.g.\u00a0\u201csocket ready to read!\u201d) or until a user-specified timeout occurs.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "Usefully, a listen()ing socket will return \u201cready to read\u201d when a new incoming connection is ready to be accept()ed.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "That\u2019s enough banter. How do we use this?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "nfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "timeout",
                        "tag": "code"
                    }
                ],
                "content": "fds is our array of information (which sockets to monitor for what), nfds is the count of elements in the array, and timeout is a timeout in milliseconds. It returns the number of elements in the array that have had an event occur.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "Let\u2019s have a look at that struct:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "events",
                        "tag": "code"
                    }
                ],
                "content": "So we\u2019re going to have an array of those, and we\u2019ll set the fd field for each element to a socket descriptor we\u2019re interested in monitoring. And then we\u2019ll set the events field to indicate the type of events we\u2019re interested in.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "events",
                        "tag": "code"
                    }
                ],
                "content": "The events field is the bitwise-OR of the following:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct pollfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "Once you have your array of struct pollfds in order, then you can pass it to poll(), also passing the size of the array, as well as a timeout value in milliseconds. (You can specify a negative timeout to wait forever.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "revents",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "POLLIN",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "POLLOUT",
                        "tag": "code"
                    }
                ],
                "content": "After poll() returns, you can check the revents field to see if POLLIN or POLLOUT is set, indicating that event occurred.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#pollman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "poll()",
                                "tag": "code"
                            }
                        ],
                        "content": "poll() man page, below",
                        "tag": "a"
                    }
                ],
                "content": "(There\u2019s actually more that you can do with the poll() call. See the poll() man page, below, for more details.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/poll.c"
                        },
                        "children": [],
                        "content": "an example",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn28",
                            "id": "fnref28",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "28",
                                "tag": "sup"
                            }
                        ],
                        "content": "28",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "RETURN",
                        "tag": "code"
                    }
                ],
                "content": "Here\u2019s an example28 where we\u2019ll wait 2.5 seconds for data to be ready to read from standard input, i.e.\u00a0when you hit RETURN:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "pfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "which",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "revents",
                        "tag": "code"
                    }
                ],
                "content": "Notice again that poll() returns the number of elements in the pfds array for which events have occurred. It doesn\u2019t tell you which elements in the array (you still have to scan for that), but it does tell you how many entries have a non-zero revents field (so you can stop scanning after you find that many).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "realloc()",
                        "tag": "code"
                    }
                ],
                "content": "A couple questions might come up here: how to add new file descriptors to the set I pass to poll()? For this, simply make sure you have enough space in the array for all you need, or realloc() more space as needed.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "What about deleting items from the set? For this, you can copy the last element in the array over-top the one you\u2019re deleting. And then pass in one fewer as the count to poll(). Another option is that you can set any fd field to a negative number and poll() will ignore it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    }
                ],
                "content": "How can we put it all together into a chat server that you can telnet to?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "What we\u2019ll do is start a listener socket, and add it to the set of file descriptors to poll(). (It will show ready-to-read when there\u2019s an incoming connection.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct pollfd",
                        "tag": "code"
                    }
                ],
                "content": "Then we\u2019ll add new connections to our struct pollfd array. And we\u2019ll grow it dynamically if we run out of space.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "When a connection is closed, we\u2019ll remove it from the array.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "And when a connection is ready-to-read, we\u2019ll read the data from it and send that data to all the other connections so they can see what the other users typed.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/pollserver.c"
                        },
                        "children": [],
                        "content": "this poll server",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn29",
                            "id": "fnref29",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "29",
                                "tag": "sup"
                            }
                        ],
                        "content": "29",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet localhost 9034",
                        "tag": "code"
                    }
                ],
                "content": "So give this poll server29 a try. Run it in one window, then telnet localhost 9034 from a number of other terminal windows. You should be able to see what you type in one window in the other ones (after you hit RETURN).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "CTRL-]",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "quit",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    }
                ],
                "content": "Not only that, but if you hit CTRL-] and type quit to exit telnet, the server should detect the disconnection and remove you from the array of file descriptors.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "In the next section, we\u2019ll look at a similar, older function called select(). Both select() and poll() offer similar functionality and performance, and only really differ in how they\u2019re used. select() might be slightly more portable, but is perhaps a little clunkier in use. Choose the one you like the best, as long as it\u2019s supported on your system.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This function is somewhat strange, but it\u2019s very useful. Take the following situation: you are a server and you want to listen for incoming connections as well as keep reading from the connections you already have.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "No problem, you say, just an accept() and a couple of recv()s. Not so fast, buster! What if you\u2019re blocking on an accept() call? How are you going to recv() data at the same time? \u201cUse non-blocking sockets!\u201d No way! You don\u2019t want to be a CPU hog. What, then?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "select() gives you the power to monitor several sockets at the same time. It\u2019ll tell you which ones are ready for reading, which are ready for writing, and which sockets have raised exceptions, if you really want to know that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            },
                            {
                                "attributes": {
                                    "href": "https://libevent.org/"
                                },
                                "children": [],
                                "content": "libevent",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn30",
                                    "id": "fnref30",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "30",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "30",
                                "tag": "a"
                            }
                        ],
                        "content": "A word of warning: select(), though very portable, is terribly slow when it comes to giant numbers of connections. In those circumstances, you\u2019ll get better performance out of an event library such as libevent30 that attempts to use the fastest possible method availabile on your system.",
                        "tag": "em"
                    }
                ],
                "content": "A word of warning: select(), though very portable, is terribly slow when it comes to giant numbers of connections. In those circumstances, you\u2019ll get better performance out of an event library such as libevent30 that attempts to use the fastest possible method availabile on your system.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "Without any further ado, I\u2019ll offer the synopsis of select():",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "readfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "writefds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "exceptfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "readfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "numfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sockfd+1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    }
                ],
                "content": "The function monitors \u201csets\u201d of file descriptors; in particular readfds, writefds, and exceptfds. If you want to see if you can read from standard input and some socket descriptor, sockfd, just add the file descriptors 0 and sockfd to the set readfds. The parameter numfds should be set to the values of the highest file descriptor plus one. In this example, it should be set to sockfd+1, since it is assuredly higher than standard input (0).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "readfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "FD_ISSET()",
                        "tag": "code"
                    }
                ],
                "content": "When select() returns, readfds will be modified to reflect which of the file descriptors you selected which is ready for reading. You can test them with the macro FD_ISSET(), below.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fd_set",
                        "tag": "code"
                    }
                ],
                "content": "Before progressing much further, I\u2019ll talk about how to manipulate these sets. Each set is of the type fd_set. The following macros operate on this type:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "Finally, what is this weirded-out struct timeval? Well, sometimes you don\u2019t want to wait forever for someone to send you some data. Maybe every 96 seconds you want to print \u201cStill Going\u2026\u201d to the terminal even though nothing has happened. This time structure allows you to specify a timeout period. If the time is exceeded and select() still hasn\u2019t found any ready file descriptors, it\u2019ll return so you can continue processing.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    }
                ],
                "content": "The struct timeval has the follow fields:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tv_sec",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tv_usec",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "timeout",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "might",
                        "tag": "em"
                    }
                ],
                "content": "Just set tv_sec to the number of seconds to wait, and set tv_usec to the number of microseconds to wait. Yes, that\u2019s _micro_seconds, not milliseconds. There are 1,000 microseconds in a millisecond, and 1,000 milliseconds in a second. Thus, there are 1,000,000 microseconds in a second. Why is it \u201cusec\u201d? The \u201cu\u201d is supposed to look like the Greek letter \u03bc (Mu) that we use for \u201cmicro\u201d. Also, when the function returns, timeout might be updated to show the time still remaining. This depends on what flavor of Unix you\u2019re running.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    }
                ],
                "content": "Yay! We have a microsecond resolution timer! Well, don\u2019t count on it. You\u2019ll probably have to wait some part of your standard Unix timeslice no matter how small you set your struct timeval.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "timeout",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "Other things of interest: If you set the fields in your struct timeval to 0, select() will timeout immediately, effectively polling all the file descriptors in your sets. If you set the parameter timeout to NULL, it will never timeout, and will wait until the first file descriptor is ready. Finally, if you don\u2019t care about waiting for a certain set, you can just set it to NULL in the call to select().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/select.c"
                        },
                        "children": [],
                        "content": "The following code snippet",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn31",
                            "id": "fnref31",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "31",
                                "tag": "sup"
                            }
                        ],
                        "content": "31",
                        "tag": "a"
                    }
                ],
                "content": "The following code snippet31 waits 2.5 seconds for something to appear on standard input:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "If you\u2019re on a line buffered terminal, the key you hit should be RETURN or it will time out anyway.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "might",
                        "tag": "em"
                    }
                ],
                "content": "Now, some of you might think this is a great way to wait for data on a datagram socket\u2014and you are right: it might be. Some Unices can use select in this manner, and some can\u2019t. You should see what your local man page says on the matter if you want to attempt it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gettimeofday()",
                        "tag": "code"
                    }
                ],
                "content": "Some Unices update the time in your struct timeval to reflect the amount of time still remaining before a timeout. But others do not. Don\u2019t rely on that occurring if you want to be portable. (Use gettimeofday() if you need to track time elapsed. It\u2019s a bummer, I know, but that\u2019s the way it is.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    }
                ],
                "content": "What happens if a socket in the read set closes the connection? Well, in that case, select() returns with that socket descriptor set as \u201cready to read\u201d. When you actually do recv() from it, recv() will return 0. That\u2019s how you know the client has closed the connection.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "readfds",
                        "tag": "code"
                    }
                ],
                "content": "One more note of interest about select(): if you have a socket that is listen()ing, you can check to see if there is a new connection by putting that socket\u2019s file descriptor in the readfds set.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "And that, my friends, is a quick overview of the almighty select() function.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But, by popular demand, here is an in-depth example. Unfortunately, the difference between the dirt-simple example, above, and this one here is significant. But have a look, then read the description that follows it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/selectserver.c"
                        },
                        "children": [],
                        "content": "This program",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn32",
                            "id": "fnref32",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "32",
                                "tag": "sup"
                            }
                        ],
                        "content": "32",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet hostname 9034",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "telnet",
                        "tag": "code"
                    }
                ],
                "content": "This program32 acts like a simple multi-user chat server. Start it running in one window, then telnet to it (\u201ctelnet hostname 9034\u201d) from multiple other windows. When you type something in one telnet session, it should appear in all the others.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "read_fds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    }
                ],
                "content": "Notice I have two file descriptor sets in the code: master and read_fds. The first, master, holds all the socket descriptors that are currently connected, as well as the socket descriptor that is listening for new connections.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "changes",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "read_fds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "The reason I have the master set is that select() actually changes the set you pass into it to reflect which sockets are ready to read. Since I have to keep track of the connections from one call of select() to the next, I must store these safely away somewhere. At the last minute, I copy the master into the read_fds, and then call select().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    }
                ],
                "content": "But doesn\u2019t this mean that every time I get a new connection, I have to add it to the master set? Yup! And every time a connection closes, I have to remove it from the master set? Yes, it does.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    }
                ],
                "content": "Notice I check to see when the listener socket is ready to read. When it is, it means I have a new connection pending, and I accept() it and add it to the master set. Similarly, when a client connection is ready to read, and recv() returns 0, I know the client has closed the connection, and I must remove it from the master set.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "master",
                        "tag": "code"
                    }
                ],
                "content": "If the client recv() returns non-zero, though, I know some data has been received. So I get it, and then go through the master list and send that data to all the rest of the connected clients.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "And that, my friends, is a less-than-simple overview of the almighty select() function.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "read()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "O_NONBLOCK",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EWOULDBLOCK",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#fcntlman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "fcntl()",
                                "tag": "code"
                            }
                        ],
                        "content": "fcntl() reference page",
                        "tag": "a"
                    }
                ],
                "content": "Quick note to all you Linux fans out there: sometimes, in rare circumstances, Linux\u2019s select() can return \u201cready-to-read\u201d and then not actually be ready to read! This means it will block on the read() after the select() says it won\u2019t! Why you little\u2014! Anyway, the workaround solution is to set the O_NONBLOCK flag on the receiving socket so it errors with EWOULDBLOCK (which you can just safely ignore if it occurs). See the fcntl() reference page for more info on setting a socket to non-blocking.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#pollman"
                        },
                        "children": [],
                        "content": "Check it out!",
                        "tag": "a"
                    }
                ],
                "content": "In addition, here is a bonus afterthought: there is another function called poll() which behaves much the same way select() does, but with a different system for managing the file descriptor sets. Check it out!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#sendrecv"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "send()",
                                "tag": "code"
                            }
                        ],
                        "content": "section about send()",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "Remember back in the section about send(), above, when I said that send() might not send all the bytes you asked it to? That is, you want it to send 512 bytes, but it returns 412. What happened to the remaining 100 bytes?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Well, they\u2019re still in your little buffer waiting to be sent out. Due to circumstances beyond your control, the kernel decided not to send all the data out in one chunk, and now, my friend, it\u2019s up to you to get the data out there.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " You could write a function like this to do it, too:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "buf",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    }
                ],
                "content": "In this example, s is the socket you want to send the data to, buf is the buffer containing the data, and len is a pointer to an int containing the number of bytes in the buffer.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendall()",
                        "tag": "code"
                    }
                ],
                "content": "The function returns -1 on error (and errno is still set from the call to send()). Also, the number of bytes actually sent is returned in len. This will be the same number of bytes you asked it to send, unless there was an error. sendall() will do it\u2019s best, huffing and puffing, to send the data out, but if there\u2019s an error, it gets back to you right away.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "For completeness, here\u2019s a sample call to the function:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "encapsulate",
                        "tag": "em"
                    },
                    {
                        "attributes": {
                            "href": "#lowlevel"
                        },
                        "children": [],
                        "content": "data encapsulation section",
                        "tag": "a"
                    }
                ],
                "content": "What happens on the receiver\u2019s end when part of a packet arrives? If the packets are variable length, how does the receiver know when one packet ends and another begins? Yes, real-world scenarios are a royal pain in the donkeys. You probably have to encapsulate (remember that from the data encapsulation section way back there at the beginning?) Read on for details!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "float",
                        "tag": "code"
                    }
                ],
                "content": "It\u2019s easy enough to send text data across the network, you\u2019re finding, but what happens if you want to send some \u201cbinary\u201d data like ints or floats? It turns out you have a few options.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sprintf()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "strtol()",
                        "tag": "code"
                    }
                ],
                "content": "Convert the number into text with a function like sprintf(), then send the text. The receiver will parse the text back into a number using a function like strtol().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "Just send the data raw, passing a pointer to the data to send().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Encode the number into a portable binary form. The receiver will decode it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Sneak preview! Tonight only!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Curtain raises",
                        "tag": "em"
                    }
                ],
                "content": "[Curtain raises]",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Beej says, \u201cI prefer Method Three, above!\u201d",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "THE END",
                        "tag": "em"
                    }
                ],
                "content": "[THE END]",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "(Before I begin this section in earnest, I should tell you that there are libraries out there for doing this, and rolling your own and remaining portable and error-free is quite a challenge. So hunt around and do your homework before deciding to implement this stuff yourself. I include the information here for those curious about how things like this work.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Actually all the methods, above, have their drawbacks and advantages, but, like I said, in general, I prefer the third method. First, though, let\u2019s talk about some of the drawbacks and advantages to the other two.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://en.wikipedia.org/wiki/Internet_Relay_Chat"
                        },
                        "children": [],
                        "content": "Internet Relay Chat (IRC)",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn33",
                            "id": "fnref33",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "33",
                                "tag": "sup"
                            }
                        ],
                        "content": "33",
                        "tag": "a"
                    }
                ],
                "content": "The first method, encoding the numbers as text before sending, has the advantage that you can easily print and read the data that\u2019s coming over the wire. Sometimes a human-readable protocol is excellent to use in a non-bandwidth-intensive situation, such as with Internet Relay Chat (IRC)33. However, it has the disadvantage that it is slow to convert, and the results almost always take up more space than the original number!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Method two: passing the raw data. This one is quite easy (but dangerous!): just take a pointer to the data to send, and call send with it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The receiver gets it like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "double",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    }
                ],
                "content": "Fast, simple\u2014what\u2019s not to like? Well, it turns out that not all architectures represent a double (or int for that matter) with the same bit representation or even the same byte ordering! The code is decidedly non-portable. (Hey\u2014maybe you don\u2019t need portability, in which case this is nice and fast.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htons()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "float",
                        "tag": "code"
                    }
                ],
                "content": "When packing integer types, we\u2019ve already seen how the htons()-class of functions can help keep things portable by transforming the numbers into Network Byte Order, and how that\u2019s the Right Thing to do. Unfortunately, there are no similar functions for float types. Is all hope lost?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Fear not! (Were you afraid there for a second? No? Not even a little bit?) There is something we can do: we can pack (or \u201cmarshal\u201d, or \u201cserialize\u201d, or one of a thousand million other names) the data into a known binary format that the receiver can unpack on the remote side.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htons()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ntohs()",
                        "tag": "code"
                    }
                ],
                "content": "What do I mean by \u201cknown binary format\u201d? Well, we\u2019ve already seen the htons() example, right? It changes (or \u201cencodes\u201d, if you want to think of it that way) a number from whatever the host format is into Network Byte Order. To reverse (unencode) the number, the receiver calls ntohs().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But didn\u2019t I just get finished saying there wasn\u2019t any such function for other non-integer types? Yes. I did. And since there\u2019s no standard way in C to do this, it\u2019s a bit of a pickle (that a gratuitous pun there for you Python fans).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "float",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/pack.c"
                        },
                        "children": [],
                        "content": "something quick and dirty with plenty of room for improvement",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn34",
                            "id": "fnref34",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "34",
                                "tag": "sup"
                            }
                        ],
                        "content": "34",
                        "tag": "a"
                    }
                ],
                "content": "The thing to do is to pack the data into a known format and send that over the wire for decoding. For example, to pack floats, here\u2019s something quick and dirty with plenty of room for improvement34:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "float",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "float",
                        "tag": "code"
                    }
                ],
                "content": "The above code is sort of a naive implementation that stores a float in a 32-bit number. The high bit (31) is used to store the sign of the number (\u201c1\u201d means negative), and the next seven bits (30-16) are used to store the whole number portion of the float. Finally, the remaining bits (15-0) are used to store the fractional portion of the number.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Usage is fairly straightforward:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "On the plus side, it\u2019s small, simple, and fast. On the minus side, it\u2019s not an efficient use of space and the range is severely restricted\u2014try storing a number greater-than 32767 in there and it won\u2019t be very happy! You can also see in the above example that the last couple decimal places are not correctly preserved.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "The",
                        "tag": "em"
                    },
                    {
                        "attributes": {
                            "href": "https://en.wikipedia.org/wiki/IEEE_754"
                        },
                        "children": [],
                        "content": "IEEE-754",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn35",
                            "id": "fnref35",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "35",
                                "tag": "sup"
                            }
                        ],
                        "content": "35",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htons()",
                        "tag": "code"
                    }
                ],
                "content": "What can we do instead? Well, The Standard for storing floating point numbers is known as IEEE-75435. Most computers use this format internally for doing floating point math, so in those cases, strictly speaking, conversion wouldn\u2019t need to be done. But if you want your source code to be portable, that\u2019s an assumption you can\u2019t necessarily make. (On the other hand, if you want things to be fast, you should optimize this out on platforms that don\u2019t need to do it! That\u2019s what htons() and its ilk do.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/ieee754.c"
                        },
                        "children": [],
                        "content": "Here\u2019s some code that encodes floats and doubles into IEEE-754 format",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn36",
                            "id": "fnref36",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "36",
                                "tag": "sup"
                            }
                        ],
                        "content": "36",
                        "tag": "a"
                    }
                ],
                "content": "Here\u2019s some code that encodes floats and doubles into IEEE-754 format36. (Mostly\u2014it doesn\u2019t encode NaN or Infinity, but it could be modified to do that.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "float",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "double",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "pack754()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bits",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "expbits",
                        "tag": "code"
                    }
                ],
                "content": "I put some handy macros up there at the top for packing and unpacking 32-bit (probably a float) and 64-bit (probably a double) numbers, but the pack754() function could be called directly and told to encode bits-worth of data (expbits of which are reserved for the normalized number\u2019s exponent).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Here\u2019s sample usage:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The above code produces this output:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "Another question you might have is how do you pack structs? Unfortunately for you, the compiler is free to put padding all over the place in a struct, and that means you can\u2019t portably send the whole thing over the wire in one chunk. (Aren\u2019t you getting sick of hearing \u201ccan\u2019t do this\u201d, \u201ccan\u2019t do that\u201d? Sorry! To quote a friend, \u201cWhenever anything goes wrong, I always blame Microsoft.\u201d This one might not be Microsoft\u2019s fault, admittedly, but my friend\u2019s statement is completely true.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    }
                ],
                "content": "Back to it: the best way to send the struct over the wire is to pack each field independently and then unpack them into the struct when they arrive on the other side.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "That\u2019s a lot of work, is what you\u2019re thinking. Yes, it is. One thing you can do is write a helper function to help pack the data for you. It\u2019ll be fun! Really!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/tpop"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "The Practice of Programming",
                                "tag": "em"
                            }
                        ],
                        "content": "The Practice of Programming",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn37",
                            "id": "fnref37",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "37",
                                "tag": "sup"
                            }
                        ],
                        "content": "37",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "printf()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "pack()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "unpack()",
                        "tag": "code"
                    }
                ],
                "content": "In the book The Practice of Programming37 by Kernighan and Pike, they implement printf()-like functions called pack() and unpack() that do exactly this. I\u2019d link to them, but apparently those functions aren\u2019t online with the rest of the source from the book.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "(The Practice of Programming is an excellent read. Zeus saves a kitten every time I recommend it.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://github.com/protobuf-c/protobuf-c"
                        },
                        "children": [],
                        "content": "Protocol Buffers implementation in C",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn38",
                            "id": "fnref38",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "38",
                                "tag": "sup"
                            }
                        ],
                        "content": "38",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "pack()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "unpack()",
                        "tag": "code"
                    }
                ],
                "content": "At this point, I\u2019m going to drop a pointer to a Protocol Buffers implementation in C38 which I\u2019ve never used, but looks completely respectable. Python and Perl programmers will want to check out their language\u2019s pack() and unpack() functions for accomplishing the same thing. And Java has a big-ol\u2019 Serializable interface that can be used in a similar way.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "printf()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/pack2.c"
                        },
                        "children": [],
                        "content": "Here\u2019s a version I cooked up",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn39",
                            "id": "fnref39",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "39",
                                "tag": "sup"
                            }
                        ],
                        "content": "39",
                        "tag": "a"
                    }
                ],
                "content": "But if you want to write your own packing utility in C, K&P\u2019s trick is to use variable argument lists to make printf()-like functions to build the packets. Here\u2019s a version I cooked up39 on my own based on that which hopefully will be enough to give you an idea of how such a thing can work.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "pack754()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "packi*()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htons()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "char",
                        "tag": "code"
                    }
                ],
                "content": "(This code references the pack754() functions, above. The packi*() functions operate like the familiar htons() family, except they pack into a char array instead of another integer.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/pack2.c"
                        },
                        "children": [],
                        "content": "here is a demonstration program",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn40",
                            "id": "fnref40",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "40",
                                "tag": "sup"
                            }
                        ],
                        "content": "40",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "buf",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "unpack()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "96s",
                        "tag": "code"
                    }
                ],
                "content": "And here is a demonstration program40 of the above code that packs some data into buf and then unpacks it into variables. Note that when calling unpack() with a string argument (format specifier \u201cs\u201d), it\u2019s wise to put a maximum length count in front of it to prevent a buffer overrun, e.g.\u00a0\u201c96s\u201d. Be wary when unpacking data you get over the network\u2014a malicious user might send badly-constructed packets in an effort to attack your system!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Whether you roll your own code or use someone else\u2019s, it\u2019s a good idea to have a general set of data packing routines for the sake of keeping bugs in check, rather than packing each bit by hand each time.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/html/rfc4506"
                        },
                        "children": [],
                        "content": "RFC 4506",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn41",
                            "id": "fnref41",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "41",
                                "tag": "sup"
                            }
                        ],
                        "content": "41",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "think",
                        "tag": "em"
                    }
                ],
                "content": "When packing the data, what\u2019s a good format to use? Excellent question. Fortunately, RFC 450641, the External Data Representation Standard, already defines binary formats for a bunch of different types, like floating point types, integer types, arrays, raw data, etc. I suggest conforming to that if you\u2019re going to roll the data yourself. But you\u2019re not obligated to. The Packet Police are not right outside your door. At least, I don\u2019t think they are.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "In any case, encoding the data somehow or another before you send it is the right way of doing things!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What does it really mean to encapsulate data, anyway? In the simplest case, it means you\u2019ll stick a header on there with either some identifying information or a packet length, or both.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What should your header look like? Well, it\u2019s just some binary data that represents whatever you feel is necessary to complete your project.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Wow. That\u2019s vague.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    }
                ],
                "content": "Okay. For instance, let\u2019s say you have a multi-user chat program that uses SOCK_STREAMs. When a user types (\u201csays\u201d) something, two pieces of information need to be transmitted to the server: what was said and who said it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "So far so good? \u201cWhat\u2019s the problem?\u201d you\u2019re asking.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The problem is that the messages can be of varying lengths. One person named \u201ctom\u201d might say, \u201cHi\u201d, and another person named \u201cBenjamin\u201d might say, \u201cHey guys what is up?\u201d",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "So you send() all this stuff to the clients as it comes in. Your outgoing data stream looks like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendall()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#sendall"
                        },
                        "children": [],
                        "content": "above",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "And so on. How does the client know when one message starts and another stops? You could, if you wanted, make all messages the same length and just call the sendall() we implemented, above. But that wastes bandwidth! We don\u2019t want to send() 1024 bytes just so \u201ctom\u201d can say \u201cHi\u201d.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "encapsulate",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "protocol",
                        "tag": "em"
                    }
                ],
                "content": "So we encapsulate the data in a tiny header and packet structure. Both the client and server know how to pack and unpack (sometimes referred to as \u201cmarshal\u201d and \u201cunmarshal\u201d) this data. Don\u2019t look now, but we\u2019re starting to define a protocol that describes how a client and server communicate!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "'\\0'",
                        "tag": "code"
                    }
                ],
                "content": "In this case, let\u2019s assume the user name is a fixed length of 8 characters, padded with '\\0'. And then let\u2019s assume the data is variable length, up to a maximum of 128 characters. Let\u2019s have a look a sample packet structure that we might use in this situation:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    }
                ],
                "content": "len (1 byte, unsigned)\u2014The total length of the packet, counting the 8-byte user name and chat data.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "name",
                        "tag": "code"
                    }
                ],
                "content": "name (8 bytes)\u2014The user\u2019s name, NUL-padded if necessary.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "chatdata",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "n",
                        "tag": "em"
                    }
                ],
                "content": "chatdata (n-bytes)\u2014The data itself, no more than 128 bytes. The length of the packet should be calculated as the length of this data plus 8 (the length of the name field, above).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Why did I choose the 8-byte and 128-byte limits for the fields? I pulled them out of the air, assuming they\u2019d be long enough. Maybe, though, 8 bytes is too restrictive for your needs, and you can have a 30-byte name field, or whatever. The choice is up to you.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Using the above packet definition, the first packet would consist of the following information (in hex and ASCII):",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "And the second is similar:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "(The length is stored in Network Byte Order, of course. In this case, it\u2019s only one byte so it doesn\u2019t matter, but generally speaking you\u2019ll want all your binary integers to be stored in Network Byte Order in your packets.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#sendall"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "sendall()",
                                "tag": "code"
                            }
                        ],
                        "content": "sendall()",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "When you\u2019re sending this data, you should be safe and use a command similar to sendall(), above, so you know all the data is sent, even if it takes multiple calls to send() to get it all out.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "18 42 65 6E 6A",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Likewise, when you\u2019re receiving this data, you need to do a bit of extra work. To be safe, you should assume that you might receive a partial packet (like maybe we receive \u201c18 42 65 6E 6A\u201d from Benjamin, above, but that\u2019s all we get in this call to recv()). We need to call recv() over and over again until the packet is completely received.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But how? Well, we know the number of bytes we need to receive in total for the packet to be complete, since that number is tacked on the front of the packet. We also know the maximum packet size is 1+8+128, or 137 bytes (because that\u2019s how we defined the packet).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "There are actually a couple things you can do here. Since you know every packet starts off with a length, you can call recv() just to get the packet length. Then once you have that, you can call it again specifying exactly the remaining length of the packet (possibly repeatedly to get all the data) until you have the complete packet. The advantage of this method is that you only need a buffer large enough for one packet, while the disadvantage is that you need to call recv() at least twice to get all the data.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Another option is just to call recv() and say the amount you\u2019re willing to receive is the maximum number of bytes in a packet. Then whatever you get, stick it onto the back of a buffer, and finally check to see if the packet is complete. Of course, you might get some of the next packet, so you\u2019ll need to have room for that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "What you can do is declare an array big enough for two packets. This is your work array where you will reconstruct packets as they arrive.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Every time you recv() data, you\u2019ll append it into the work buffer and check to see if the packet is complete. That is, the number of bytes in the buffer is greater than or equal to the length specified in the header (+1, because the length in the header doesn\u2019t include the byte for the length itself). If the number of bytes in the buffer is less than 1, the packet is not complete, obviously. You have to make a special case for this, though, since the first byte is garbage and you can\u2019t rely on it for the correct packet length.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Once the packet is complete, you can do with it what you will. Use it, and remove it from your work buffer.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "two",
                        "tag": "em"
                    }
                ],
                "content": "Whew! Are you juggling that in your head yet? Well, here\u2019s the second of the one-two punch: you might have read past the end of one packet and onto the next in a single recv() call. That is, you have a work buffer with one complete packet, and an incomplete part of the next packet! Bloody heck. (But this is why you made your work buffer large enough to hold two packets\u2014in case this happened!)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Since you know the length of the first packet from the header, and you\u2019ve been keeping track of the number of bytes in the work buffer, you can subtract and calculate how many of the bytes in the work buffer belong to the second (incomplete) packet. When you\u2019ve handled the first one, you can clear it out of the work buffer and move the partial second packet down the to front of the buffer so it\u2019s all ready to go for the next recv().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "(Some of you readers will note that actually moving the partial second packet to the beginning of the work buffer takes time, and the program can be coded to not require this by using a circular buffer. Unfortunately for the rest of you, a discussion on circular buffers is beyond the scope of this article. If you\u2019re still curious, grab a data structures book and go from there.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "I never said it was easy. Ok, I did say it was easy. And it is; you just need practice and pretty soon it\u2019ll come to you naturally. By Excalibur I swear it!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "at the same time",
                        "tag": "em"
                    }
                ],
                "content": "So far, this guide has talked about sending data from one host to one other host. But it is possible, I insist, that you can, with the proper authority, send data to multiple hosts at the same time!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "broadcasting",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "multicasting",
                        "tag": "em"
                    }
                ],
                "content": "With UDP (only UDP, not TCP) and standard IPv4, this is done through a mechanism called broadcasting. With IPv6, broadcasting isn\u2019t supported, and you have to resort to the often superior technique of multicasting, which, sadly I won\u2019t be discussing at this time. But enough of the starry-eyed future\u2014we\u2019re stuck in the 32-bit present.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_BROADCAST",
                        "tag": "code"
                    }
                ],
                "content": "But wait! You can\u2019t just run off and start broadcasting willy-nilly; You have to set the socket option SO_BROADCAST before you can send a broadcast packet out on the network. It\u2019s like a one of those little plastic covers they put over the missile launch switch! That\u2019s just how much power you hold in your hands!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But seriously, though, there is a danger to using broadcast packets, and that is: every system that receives a broadcast packet must undo all the onion-skin layers of data encapsulation until it finds out what port the data is destined to. And then it hands the data over or discards it. In either case, it\u2019s a lot of work for each machine that receives the broadcast packet, and since it is all of them on the local network, that could be a lot of machines doing a lot of unnecessary work. When the game Doom first came out, this was a complaint about its network code.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Now, there is more than one way to skin a cat\u2026 wait a minute. Is there really more than one way to skin a cat? What kind of expression is that? Uh, and likewise, there is more than one way to send a broadcast packet. So, to get to the meat and potatoes of the whole thing: how do you specify the destination address for a broadcast message? There are two common ways:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.168.1.0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.255.255.0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.168.1.255",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ifconfig",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "network_number",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "netmask",
                        "tag": "code"
                    }
                ],
                "content": "Send the data to a specific subnet\u2019s broadcast address. This is the subnet\u2019s network number with all one-bits set for the host portion of the address. For instance, at home my network is 192.168.1.0, my netmask is 255.255.255.0, so the last byte of the address is my host number (because the first three bytes, according to the netmask, are the network number). So my broadcast address is 192.168.1.255. Under Unix, the ifconfig command will actually give you all this data. (If you\u2019re curious, the bitwise logic to get your broadcast address is network_number OR (NOT netmask).) You can send this type of broadcast packet to remote networks as well as your local network, but you run the risk of the packet being dropped by the destination\u2019s router. (If they didn\u2019t drop it, then some random smurf could start flooding their LAN with broadcast traffic.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.255.255.255",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_BROADCAST",
                        "tag": "code"
                    }
                ],
                "content": "Send the data to the \u201cglobal\u201d broadcast address. This is 255.255.255.255, aka INADDR_BROADCAST. Many machines will automatically bitwise AND this with your network number to convert it to a network broadcast address, but some won\u2019t. It varies. Routers do not forward this type of broadcast packet off your local network, ironically enough.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_BROADCAST",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#datagram"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "talker",
                                "tag": "code"
                            },
                            {
                                "attributes": {},
                                "children": [],
                                "content": "listener",
                                "tag": "code"
                            }
                        ],
                        "content": "talker and listener",
                        "tag": "a"
                    }
                ],
                "content": "So what happens if you try to send data on the broadcast address without first setting the SO_BROADCAST socket option? Well, let\u2019s fire up good old talker and listener and see what happens.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_BROADCAST",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    }
                ],
                "content": "Yes, it\u2019s not happy at all\u2026because we didn\u2019t set the SO_BROADCAST socket option. Do that, and now you can sendto() anywhere you want!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "only difference",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "talker",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_BROADCAST",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/bgnet/source/examples/broadcaster.c"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "broadcaster.c",
                                "tag": "code"
                            }
                        ],
                        "content": "broadcaster.c",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn42",
                            "id": "fnref42",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "42",
                                "tag": "sup"
                            }
                        ],
                        "content": "42",
                        "tag": "a"
                    }
                ],
                "content": "In fact, that\u2019s the only difference between a UDP application that can broadcast and one that can\u2019t. So let\u2019s take the old talker application and add one section that sets the SO_BROADCAST socket option. We\u2019ll call this program broadcaster.c42:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#datagram"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "listener",
                                "tag": "code"
                            }
                        ],
                        "content": "listener",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "broadcaster",
                        "tag": "code"
                    }
                ],
                "content": "What\u2019s different between this and a \u201cnormal\u201d UDP client/server situation? Nothing! (With the exception of the client being allowed to send broadcast packets in this case.) As such, go ahead and run the old UDP listener program in one window, and broadcaster in another. You should be now be able to do all those sends that failed, above.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener.c",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    }
                ],
                "content": "And you should see listener responding that it got the packets. (If listener doesn\u2019t respond, it could be because it\u2019s bound to an IPv6 address. Try changing the AF_INET6 in listener.c to AF_INET to force IPv4.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "broadcaster",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    }
                ],
                "content": "Well, that\u2019s kind of exciting. But now fire up listener on another machine next to you on the same network so that you have two copies going, one on each machine, and run broadcaster again with your broadcast address\u2026 Hey! Both listeners get the packet even though you only called sendto() once! Cool!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listener",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "nyah",
                        "tag": "em"
                    }
                ],
                "content": "If the listener gets data you send directly to it, but not data on the broadcast address, it could be that you have a firewall on your local machine that is blocking the packets. (Yes, Pat and Bapper, thank you for realizing before I did that this is why my sample code wasn\u2019t working. I told you I\u2019d mention you in the guide, and here you are. So nyah.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": "Again, be careful with broadcast packets. Since every machine on the LAN will be forced to deal with the packet whether it recvfrom()s it or not, it can present quite a load to the entire computing network. They are definitely to be used sparingly and appropriately.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Where can I get those header files?",
                        "tag": "strong"
                    }
                ],
                "content": "Where can I get those header files?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "#include <winsock.h>",
                        "tag": "code"
                    }
                ],
                "content": " If you don\u2019t have them on your system already, you probably don\u2019t need them. Check the manual for your particular platform. If you\u2019re building for Windows, you only need to #include <winsock.h>.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "What do I do when bind() reports \u201cAddress already in use\u201d?",
                        "tag": "strong"
                    }
                ],
                "content": "What do I do when bind() reports \u201cAddress already in use\u201d?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "setsockopt()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_REUSEADDR",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#bind"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "section on bind()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#select"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            }
                        ],
                        "content": "section on select()",
                        "tag": "a"
                    }
                ],
                "content": "You have to use setsockopt() with the SO_REUSEADDR option on the listening socket. Check out the section on bind() and the section on select() for an example.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How do I get a list of open sockets on the system?",
                        "tag": "strong"
                    }
                ],
                "content": "How do I get a list of open sockets on the system?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "netstat",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man",
                        "tag": "code"
                    }
                ],
                "content": "Use the netstat. Check the man page for full details, but you should get some good output just typing:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "The only trick is determining which socket is associated with which program. :-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How can I view the routing table?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I view the routing table?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "route",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "/sbin",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "netstat -r",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ip route",
                        "tag": "code"
                    }
                ],
                "content": "Run the route command (in /sbin on most Linuxes) or the command netstat -r. Or the command ip route.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How can I run the client and server programs if I only have one computer? Don\u2019t I need a network to write network programs?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I run the client and server programs if I only have one computer? Don\u2019t I need a network to write network programs?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "lo",
                        "tag": "code"
                    }
                ],
                "content": "Fortunately for you, virtually all machines implement a loopback network \u201cdevice\u201d that sits in the kernel and pretends to be a network card. (This is the interface listed as \u201clo\u201d in the routing table.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "goat",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "server &",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "client goat",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "client localhost",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "localhost",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "/etc/hosts",
                        "tag": "code"
                    }
                ],
                "content": "Pretend you\u2019re logged into a machine named \u201cgoat\u201d. Run the client in one window and the server in another. Or start the server in the background (\u201cserver &\u201d) and run the client in the same window. The upshot of the loopback device is that you can either client goat or client localhost (since \u201clocalhost\u201d is likely defined in your /etc/hosts file) and you\u2019ll have the client talking to the server without a network!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "In short, no changes are necessary to any of the code to make it run on a single non-networked machine! Huzzah!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How can I tell if the remote side has closed connection?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I tell if the remote side has closed connection?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    }
                ],
                "content": "You can tell because recv() will return 0.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "SOCK_RAW",
                                "tag": "code"
                            }
                        ],
                        "content": "How do I implement a \u201cping\u201d utility? What is ICMP? Where can I find out more about raw sockets and SOCK_RAW?",
                        "tag": "strong"
                    }
                ],
                "content": "How do I implement a \u201cping\u201d utility? What is ICMP? Where can I find out more about raw sockets and SOCK_RAW?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#books"
                        },
                        "children": [],
                        "content": "W. Richard Stevens\u2019 UNIX Network Programming books",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ping/",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "http://www.unpbook.com/src.html"
                        },
                        "children": [],
                        "content": "available online",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn43",
                            "id": "fnref43",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "43",
                                "tag": "sup"
                            }
                        ],
                        "content": "43",
                        "tag": "a"
                    }
                ],
                "content": "All your raw sockets questions will be answered in W. Richard Stevens\u2019 UNIX Network Programming books. Also, look in the ping/ subdirectory in Stevens\u2019 UNIX Network Programming source code, available online43.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "connect()",
                                "tag": "code"
                            }
                        ],
                        "content": "How do I change or shorten the timeout on a call to connect()?",
                        "tag": "strong"
                    }
                ],
                "content": "How do I change or shorten the timeout on a call to connect()?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "http://www.unpbook.com/src.html"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "lib/connect_nonb.c",
                                "tag": "code"
                            }
                        ],
                        "content": "lib/connect_nonb.c in the UNIX Network Programming source code",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn44",
                            "id": "fnref44",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "44",
                                "tag": "sup"
                            }
                        ],
                        "content": "44",
                        "tag": "a"
                    }
                ],
                "content": "Instead of giving you exactly the same answer that W. Richard Stevens would give you, I\u2019ll just refer you to lib/connect_nonb.c in the UNIX Network Programming source code44.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#blocking"
                        },
                        "children": [],
                        "content": "set it to non-blocking",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EINPROGRESS",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#select"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            }
                        ],
                        "content": "select()",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getsockopt()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_ERROR",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "The gist of it is that you make a socket descriptor with socket(), set it to non-blocking, call connect(), and if all goes well connect() will return -1 immediately and errno will be set to EINPROGRESS. Then you call select() with whatever timeout you want, passing the socket descriptor in both the read and write sets. If it doesn\u2019t timeout, it means the connect() call completed. At this point, you\u2019ll have to use getsockopt() with the SO_ERROR option to get the return value from the connect() call, which should be zero if there was no error.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Finally, you\u2019ll probably want to set the socket back to be blocking again before you start transferring data over it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "Notice that this has the added benefit of allowing your program to do something else while it\u2019s connecting, too. You could, for example, set the timeout to something low, like 500 ms, and update an indicator onscreen each timeout, then call select() again. When you\u2019ve called select() and timed-out, say, 20 times, you\u2019ll know it\u2019s time to give up on the connection.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Like I said, check out Stevens\u2019 source for a perfectly excellent example.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How do I build for Windows?",
                        "tag": "strong"
                    }
                ],
                "content": "How do I build for Windows?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "};-)",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#windows"
                        },
                        "children": [],
                        "content": "section on building for Windows",
                        "tag": "a"
                    }
                ],
                "content": "First, delete Windows and install Linux or BSD. };-). No, actually, just see the section on building for Windows in the introduction.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How do I build for Solaris/SunOS? I keep getting linker errors when I try to compile!",
                        "tag": "strong"
                    }
                ],
                "content": "How do I build for Solaris/SunOS? I keep getting linker errors when I try to compile!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#solaris"
                        },
                        "children": [],
                        "content": "section on building for Solaris/SunOS",
                        "tag": "a"
                    }
                ],
                "content": "The linker errors happen because Sun boxes don\u2019t automatically compile in the socket libraries. See the section on building for Solaris/SunOS in the introduction for an example of how to do this.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            }
                        ],
                        "content": "Why does select() keep falling out on a signal?",
                        "tag": "strong"
                    }
                ],
                "content": "Why does select() keep falling out on a signal?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EINTR",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sigaction()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SA_RESTART",
                        "tag": "code"
                    }
                ],
                "content": "Signals tend to cause blocked system calls to return -1 with errno set to EINTR. When you set up a signal handler with sigaction(), you can set the flag SA_RESTART, which is supposed to restart the system call after it was interrupted.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Naturally, this doesn\u2019t always work.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "goto",
                        "tag": "code"
                    }
                ],
                "content": "My favorite solution to this involves a goto statement. You know this irritates your professors to no end, so go for it!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "need",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "goto",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "goto",
                        "tag": "code"
                    }
                ],
                "content": "Sure, you don\u2019t need to use goto in this case; you can use other structures to control it. But I think the goto statement is actually cleaner.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "recv()",
                                "tag": "code"
                            }
                        ],
                        "content": "How can I implement a timeout on a call to recv()?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I implement a timeout on a call to recv()?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#select"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            }
                        ],
                        "content": "select()",
                        "tag": "a"
                    }
                ],
                "content": " Use select()! It allows you to specify a timeout parameter for socket descriptors that you\u2019re looking to read from. Or, you could wrap the entire functionality in a single function, like this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvtimeout()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-2",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-2",
                        "tag": "code"
                    }
                ],
                "content": "Notice that recvtimeout() returns -2 in case of a timeout. Why not return 0? Well, if you recall, a return value of 0 on a call to recv() means that the remote side closed the connection. So that return value is already spoken for, and -1 means \u201cerror\u201d, so I chose -2 as my timeout indicator.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How do I encrypt or compress the data before sending it through the socket?",
                        "tag": "strong"
                    }
                ],
                "content": "How do I encrypt or compress the data before sending it through the socket?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://www.openssl.org/"
                        },
                        "children": [],
                        "content": "OpenSSL project",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn45",
                            "id": "fnref45",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "45",
                                "tag": "sup"
                            }
                        ],
                        "content": "45",
                        "tag": "a"
                    }
                ],
                "content": "One easy way to do encryption is to use SSL (secure sockets layer), but that\u2019s beyond the scope of this guide. (Check out the OpenSSL project45 for more info.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But assuming you want to plug in or implement your own compressor or encryption system, it\u2019s just a matter of thinking of your data as running through a sequence of steps between both ends. Each step changes the data in some way.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Now the other way around:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "If you\u2019re going to compress and encrypt, just remember to compress first. :-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Just as long as the client properly undoes what the server does, the data will be fine in the end no matter how many intermediate steps you add.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "So all you need to do to use my code is to find the place between where the data is read and the data is sent (using send()) over the network, and stick some code in there that does the encryption.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "PF_INET",
                                "tag": "code"
                            },
                            {
                                "attributes": {},
                                "children": [],
                                "content": "AF_INET",
                                "tag": "code"
                            }
                        ],
                        "content": "What is this \u201cPF_INET\u201d I keep seeing? Is it related to AF_INET?",
                        "tag": "strong"
                    }
                ],
                "content": "What is this \u201cPF_INET\u201d I keep seeing? Is it related to AF_INET?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#socket"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "socket()",
                                "tag": "code"
                            }
                        ],
                        "content": "the section on socket()",
                        "tag": "a"
                    }
                ],
                "content": "Yes, yes it is. See the section on socket() for details.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How can I write a server that accepts shell commands from a client and executes them?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I write a server that accepts shell commands from a client and executes them?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "For simplicity, lets say the client connect()s, send()s, and close()s the connection (that is, there are no subsequent system calls without the client connecting again).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The process the client follows is this:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Meanwhile, the server is handling the data and executing it:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Beware!",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "rm -rf ~",
                        "tag": "code"
                    }
                ],
                "content": " Beware! Having the server execute what the client says is like giving remote shell access and people can do things to your account when they connect to the server. For instance, in the above example, what if the client sends \u201crm -rf ~\u201d? It deletes everything in your account, that\u2019s what!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "foobar",
                        "tag": "code"
                    }
                ],
                "content": "So you get wise, and you prevent the client from using any except for a couple utilities that you know are safe, like the foobar utility:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "foobar; rm -rf ~",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "\\",
                        "tag": "code"
                    }
                ],
                "content": "But you\u2019re still unsafe, unfortunately: what if the client enters \u201cfoobar; rm -rf ~\u201d? The safest thing to do is to write a little routine that puts an escape (\u201c\\\u201d) character in front of all non-alphanumeric characters (including spaces, if appropriate) in the arguments for the command.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "As you can see, security is a pretty big issue when the server starts executing things the client sends.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "recv()",
                                "tag": "code"
                            }
                        ],
                        "content": "I\u2019m sending a slew of data, but when I recv(), it only receives 536 bytes or 1460 bytes at a time. But if I run it on my local machine, it receives all the data at the same time. What\u2019s going on?",
                        "tag": "strong"
                    }
                ],
                "content": "I\u2019m sending a slew of data, but when I recv(), it only receives 536 bytes or 1460 bytes at a time. But if I run it on my local machine, it receives all the data at the same time. What\u2019s going on?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "You\u2019re hitting the MTU\u2014the maximum size the physical medium can handle. On the local machine, you\u2019re using the loopback device which can handle 8K or more no problem. But on Ethernet, which can only handle 1500 bytes with a header, you hit that limit. Over a modem, with 576 MTU (again, with header), you hit the even lower limit.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#sendall"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "sendall()",
                                "tag": "code"
                            }
                        ],
                        "content": "sendall()",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "You have to make sure all the data is being sent, first of all. (See the sendall() function implementation for details.) Once you\u2019re sure of that, then you need to call recv() in a loop until all your data is read.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#sonofdataencap"
                        },
                        "children": [],
                        "content": "Son of Data Encapsulation",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Read the section Son of Data Encapsulation for details on receiving complete packets of data using multiple calls to recv().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "fork()",
                                "tag": "code"
                            },
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct sigaction",
                                "tag": "code"
                            }
                        ],
                        "content": "I\u2019m on a Windows box and I don\u2019t have the fork() system call or any kind of struct sigaction. What to do?",
                        "tag": "strong"
                    }
                ],
                "content": "I\u2019m on a Windows box and I don\u2019t have the fork() system call or any kind of struct sigaction. What to do?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sigaction",
                        "tag": "code"
                    }
                ],
                "content": " If they\u2019re anywhere, they\u2019ll be in POSIX libraries that may have shipped with your compiler. Since I don\u2019t have a Windows box, I really can\u2019t tell you the answer, but I seem to remember that Microsoft has a POSIX compatibility layer and that\u2019s where fork() would be. (And maybe even sigaction.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Search the help that came with VC++ for \u201cfork\u201d or \u201cPOSIX\u201d and see if it gives you any clues.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fork()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sigaction",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "CreateProcess()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "CreateProcess()",
                        "tag": "code"
                    }
                ],
                "content": "If that doesn\u2019t work at all, ditch the fork()/sigaction stuff and replace it with the Win32 equivalent: CreateProcess(). I don\u2019t know how to use CreateProcess()\u2014it takes a bazillion arguments, but it should be covered in the docs that came with VC++.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": " I\u2019m behind a firewall\u2014how do I let people outside the firewall know my IP address so they can connect to my machine?",
                        "tag": "strong"
                    }
                ],
                "content": " I\u2019m behind a firewall\u2014how do I let people outside the firewall know my IP address so they can connect to my machine?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Unfortunately, the purpose of a firewall is to prevent people outside the firewall from connecting to machines inside the firewall, so allowing them to do so is basically considered a breach of security.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "This isn\u2019t to say that all is lost. For one thing, you can still often connect() through the firewall if it\u2019s doing some kind of masquerading or NAT or something like that. Just design your programs so that you\u2019re always the one initiating the connection, and you\u2019ll be fine.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " If that\u2019s not satisfactory, you can ask your sysadmins to poke a hole in the firewall so that people can connect to you. The firewall can forward to you either through it\u2019s NAT software, or through a proxy or something like that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Be aware that a hole in the firewall is nothing to be taken lightly. You have to make sure you don\u2019t give bad people access to the internal network; if you\u2019re a beginner, it\u2019s a lot harder to make software secure than you might imagine.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": ";-)",
                        "tag": "code"
                    }
                ],
                "content": "Don\u2019t make your sysadmin mad at me. ;-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": " How do I write a packet sniffer? How do I put my Ethernet interface into promiscuous mode?",
                        "tag": "strong"
                    }
                ],
                "content": " How do I write a packet sniffer? How do I put my Ethernet interface into promiscuous mode?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#lowlevel"
                        },
                        "children": [],
                        "content": "Low Level Nonsense and Network Theory",
                        "tag": "a"
                    }
                ],
                "content": "For those not in the know, when a network card is in \u201cpromiscuous mode\u201d, it will forward ALL packets to the operating system, not just those that were addressed to this particular machine. (We\u2019re talking Ethernet-layer addresses here, not IP addresses\u2013but since ethernet is lower-layer than IP, all IP addresses are effectively forwarded as well. See the section Low Level Nonsense and Network Theory for more info.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This is the basis for how a packet sniffer works. It puts the interface into promiscuous mode, then the OS gets every single packet that goes by on the wire. You\u2019ll have a socket of some type that you can read this data from.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://stackoverflow.com/questions/21323023/"
                        },
                        "children": [],
                        "content": "useful Stack Overflow thread",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn46",
                            "id": "fnref46",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "46",
                                "tag": "sup"
                            }
                        ],
                        "content": "46",
                        "tag": "a"
                    }
                ],
                "content": "Unfortunately, the answer to the question varies depending on the platform, but if you Google for, for instance, \u201cwindows promiscuous ioctl\u201d you\u2019ll probably get somewhere. For Linux, there\u2019s what looks like a useful Stack Overflow thread46, as well.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How can I set a custom timeout value for a TCP or UDP socket?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I set a custom timeout value for a TCP or UDP socket?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_RCVTIMEO",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SO_SNDTIMEO",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "setsockopt()",
                        "tag": "code"
                    }
                ],
                "content": "It depends on your system. You might search the net for SO_RCVTIMEO and SO_SNDTIMEO (for use with setsockopt()) to see if your system supports such functionality.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "alarm()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "setitimer()",
                        "tag": "code"
                    }
                ],
                "content": "The Linux man page suggests using alarm() or setitimer() as a substitute.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "How can I tell which ports are available to use? Is there a list of \u201cofficial\u201d port numbers?",
                        "tag": "strong"
                    }
                ],
                "content": "How can I tell which ports are available to use? Is there a list of \u201cofficial\u201d port numbers?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Usually this isn\u2019t an issue. If you\u2019re writing, say, a web server, then it\u2019s a good idea to use the well-known port 80 for your software. If you\u2019re writing just your own specialized server, then choose a port at random (but greater than 1023) and give it a try.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "If the port is already in use, you\u2019ll get an \u201cAddress already in use\u201d error when you try to bind(). Choose another port. (It\u2019s a good idea to allow the user of your software to specify an alternate port either with a config file or a command line switch.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://www.iana.org/assignments/port-numbers"
                        },
                        "children": [],
                        "content": "list of official port numbers",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn47",
                            "id": "fnref47",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "47",
                                "tag": "sup"
                            }
                        ],
                        "content": "47",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "on the same machine",
                        "tag": "em"
                    }
                ],
                "content": "There is a list of official port numbers47 maintained by the Internet Assigned Numbers Authority (IANA). Just because something (over 1023) is in that list doesn\u2019t mean you can\u2019t use the port. For instance, Id Software\u2019s DOOM uses the same port as \u201cmdqs\u201d, whatever that is. All that matters is that no one else on the same machine is using that port when you want to use it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "In the Unix world, there are a lot of manuals. They have little sections that describe individual functions that you have at your disposal.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "manual",
                        "tag": "code"
                    }
                ],
                "content": "Of course, manual would be too much of a thing to type. I mean, no one in the Unix world, including myself, likes to type that much. Indeed I could go on and on at great length about how much I prefer to be terse but instead I shall be brief and not bore you with long-winded diatribes about how utterly amazingly brief I prefer to be in virtually all circumstances in their entirety.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "[Applause]",
                        "tag": "em"
                    }
                ],
                "content": "[Applause]",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Thank you. What I am getting at is that these pages are called \u201cman pages\u201d in the Unix world, and I have included my own personal truncated variant here for your reading enjoyment. The thing is, many of these functions are way more general purpose than I\u2019m letting on, but I\u2019m only going to present the parts that are relevant for Internet Sockets Programming.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "But wait! That\u2019s not all that\u2019s wrong with my man pages:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man whatever",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept",
                        "tag": "code"
                    }
                ],
                "content": "If you want the real information, check your local Unix man pages by typing man whatever, where \u201cwhatever\u201d is something that you\u2019re incredibly interested in, such as \u201caccept\u201d. (I\u2019m sure Microsoft Visual Studio has something similar in their help section. But \u201cman\u201d is better because it is one byte more concise than \u201chelp\u201d. Unix wins again!)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "So, if these are so flawed, why even include them at all in the Guide? Well, there are a few reasons, but the best are that (a) these versions are geared specifically toward network programming and are easier to digest than the real ones, and (b) these versions contain examples!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Oh! And speaking of the examples, I don\u2019t tend to put in all the error checking because it really increases the length of the code. But you should absolutely do error checking pretty much any time you make any of the system calls unless you\u2019re totally 100% sure it\u2019s not going to fail, and you should probably do it even then!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Accept an incoming connection on a listening socket",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "Once you\u2019ve gone through the trouble of getting a SOCK_STREAM socket and setting it up for incoming connections with listen(), then you call accept() to actually get yourself a new socket descriptor to use for subsequent communication with the newly connected client.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "The old socket that you are using for listening is still there, and will be used for further accept() calls as they come in.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "O_NONBLOCK",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fcntl()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EWOULDBLOCK",
                        "tag": "code"
                    }
                ],
                "content": "accept() will normally block, and you can use select() to peek on the listening socket descriptor ahead of time to see if it\u2019s \u201cready to read\u201d. If so, then there\u2019s a new connection waiting to be accept()ed! Yay! Alternatively, you could set the O_NONBLOCK flag on the listening socket using fcntl(), and then it will never block, choosing instead to return -1 with errno set to EWOULDBLOCK.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "The socket descriptor returned by accept() is a bona fide socket descriptor, open and connected to the remote host. You have to close() it when you\u2019re done with it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "accept() returns the newly connected socket descriptor, or -1 on error, with errno set appropriately.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#socketman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "socket()",
                                "tag": "code"
                            }
                        ],
                        "content": "socket()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#getaddrinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#listenman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "listen()",
                                "tag": "code"
                            }
                        ],
                        "content": "listen()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#structsockaddrman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct sockaddr_in",
                                "tag": "code"
                            }
                        ],
                        "content": "struct sockaddr_in",
                        "tag": "a"
                    }
                ],
                "content": "socket(), getaddrinfo(), listen(), struct sockaddr_in",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Associate a socket with an IP address and port number",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "When a remote machine wants to connect to your server program, it needs two pieces of information: the IP address and the port number. The bind() call allows you to do just that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "First, you call getaddrinfo() to load up a struct sockaddr with the destination address and port information. Then you call socket() to get a socket descriptor, and then you pass the socket and address into bind(), and the IP address and port are magically (using actual magic) bound to the socket!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hints",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "If you don\u2019t know your IP address, or you know you only have one IP address on the machine, or you don\u2019t care which of the machine\u2019s IP addresses is used, you can simply pass the AI_PASSIVE flag in the hints parameter to getaddrinfo(). What this does is fill in the IP address part of the struct sockaddr with a special value that tells bind() that it should automatically fill in this host\u2019s IP address.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_addr.s_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_ANY",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "in6addr_any",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "IN6ADDR_ANY_INIT",
                        "tag": "code"
                    }
                ],
                "content": "What what? What special value is loaded into the struct sockaddr\u2019s IP address to cause it to auto-fill the address with the current host? I\u2019ll tell you, but keep in mind this is only if you\u2019re filling out the struct sockaddr by hand; if not, use the results from getaddrinfo(), as per above. In IPv4, the sin_addr.s_addr field of the struct sockaddr_in structure is set to INADDR_ANY. In IPv6, the sin6_addr field of the struct sockaddr_in6 structure is assigned into from the global variable in6addr_any. Or, if you\u2019re declaring a new struct in6_addr, you can initialize it to IN6ADDR_ANY_INIT.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addrlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof my_addr",
                        "tag": "code"
                    }
                ],
                "content": "Lastly, the addrlen parameter should be set to sizeof my_addr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#getaddrinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#socketman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "socket()",
                                "tag": "code"
                            }
                        ],
                        "content": "socket()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#structsockaddrman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct sockaddr_in",
                                "tag": "code"
                            }
                        ],
                        "content": "struct sockaddr_in",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#structsockaddrman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct in_addr",
                                "tag": "code"
                            }
                        ],
                        "content": "struct in_addr",
                        "tag": "a"
                    }
                ],
                "content": "getaddrinfo(), socket(), struct sockaddr_in, struct in_addr",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Connect a socket to a server",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    }
                ],
                "content": "Once you\u2019ve built a socket descriptor with the socket() call, you can connect() that socket to a remote server using the well-named connect() system call. All you need to do is pass it the socket descriptor and the address of the server you\u2019re interested in getting to know better. (Oh, and the length of the address, which is commonly passed to functions like this.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Usually this information comes along as the result of a call to getaddrinfo(), but you can fill out your own struct sockaddr if you want to.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "serv_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "can",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "If you haven\u2019t yet called bind() on the socket descriptor, it is automatically bound to your IP address and a random local port. This is usually just fine with you if you\u2019re not a server, since you really don\u2019t care what your local port is; you only care what the remote port is so you can put it in the serv_addr parameter. You can call bind() if you really want your client socket to be on a specific IP address and port, but this is pretty rare.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "Once the socket is connect()ed, you\u2019re free to send() and recv() data on it to your heart\u2019s content.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": " Special note: if you connect() a SOCK_DGRAM UDP socket to a remote host, you can use send() and recv() as well as sendto() and recvfrom(). If you want.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#socketman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "socket()",
                                "tag": "code"
                            }
                        ],
                        "content": "socket()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#bindman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "bind()",
                        "tag": "a"
                    }
                ],
                "content": "socket(), bind()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Close a socket descriptor",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "anything else",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "After you\u2019ve finished using the socket for whatever demented scheme you have concocted and you don\u2019t want to send() or recv() or, indeed, do anything else at all with the socket, you can close() it, and it\u2019ll be freed up, never to be used again.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SIGPIPE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EPIPE",
                        "tag": "code"
                    }
                ],
                "content": "The remote side can tell if this happens one of two ways. One: if the remote side calls recv(), it will return 0. Two: if the remote side calls send(), it\u2019ll receive a signal SIGPIPE and send() will return -1 and errno will be set to EPIPE.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Windows users",
                        "tag": "strong"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "closesocket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": " Windows users: the function you need to use is called closesocket(), not close(). If you try to use close() on a socket descriptor, it\u2019s possible Windows will get angry\u2026 And you wouldn\u2019t like it when it\u2019s angry.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#socketman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "socket()",
                                "tag": "code"
                            }
                        ],
                        "content": "socket()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#shutdownman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "shutdown()",
                                "tag": "code"
                            }
                        ],
                        "content": "shutdown()",
                        "tag": "a"
                    }
                ],
                "content": "socket(), shutdown()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Get information about a host name and/or service and load up a struct sockaddr with the result.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getservbyname()",
                        "tag": "code"
                    }
                ],
                "content": "getaddrinfo() is an excellent function that will return information on a particular host name (such as its IP address) and load up a struct sockaddr for you, taking care of the gritty details (like if it\u2019s IPv4 or IPv6). It replaces the old functions gethostbyname() and getservbyname().The description, below, contains a lot of information that might be a little daunting, but actual usage is pretty simple. It might be worth it to check out the examples first.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "nodename",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    }
                ],
                "content": "The host name that you\u2019re interested in goes in the nodename parameter. The address can be either a host name, like \u201cwww.example.com\u201d, or an IPv4 or IPv6 address (passed as a string). This parameter can also be NULL if you\u2019re using the AI_PASSIVE flag (see below).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "servname",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "https://www.iana.org/assignments/port-numbers"
                        },
                        "children": [],
                        "content": "IANA Port List",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn48",
                            "id": "fnref48",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "48",
                                "tag": "sup"
                            }
                        ],
                        "content": "48",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "/etc/services",
                        "tag": "code"
                    }
                ],
                "content": "The servname parameter is basically the port number. It can be a port number (passed as a string, like \u201c80\u201d), or it can be a service name, like \u201chttp\u201d or \u201ctftp\u201d or \u201csmtp\u201d or \u201cpop\u201d, etc. Well-known service names can be found in the IANA Port List48 or in your /etc/services file.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hints",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "memset()",
                        "tag": "code"
                    }
                ],
                "content": "Lastly, for input parameters, we have hints. This is really where you get to define what the getaddrinfo() function is going to do. Zero the whole structure before use with memset(). Let\u2019s take a look at the fields you need to set up before use.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_flags",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "|",
                        "tag": "code"
                    }
                ],
                "content": "The ai_flags can be set to a variety of things, but here are a couple important ones. (Multiple flags can be specified by bitwise-ORing them together with the | operator). Check your man page for the complete list of flags.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_CANONNAME",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_canonname",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INADDR_ANY",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "in6addr_any",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "AI_CANONNAME causes the ai_canonname of the result to the filled out with the host\u2019s canonical (real) name. AI_PASSIVE causes the result\u2019s IP address to be filled out with INADDR_ANY (IPv4) or in6addr_any (IPv6); this causes a subsequent call to bind() to auto-fill the IP address of the struct sockaddr with the address of the current host. That\u2019s excellent for setting up a server when you don\u2019t want to hardcode the address.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "nodename",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "If you do use the AI_PASSIVE, flag, then you can pass NULL in the nodename (since bind() will fill it in for you later).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_family",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_UNSPEC",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    }
                ],
                "content": "Continuing on with the input parameters, you\u2019ll likely want to set ai_family to AF_UNSPEC which tells getaddrinfo() to look for both IPv4 and IPv6 addresses. You can also restrict yourself to one or the other with AF_INET or AF_INET6.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socktype",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    }
                ],
                "content": "Next, the socktype field should be set to SOCK_STREAM or SOCK_DGRAM, depending on which type of socket you want.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ai_protocol",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    }
                ],
                "content": "Finally, just leave ai_protocol at 0 to automatically choose your protocol type.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "finally",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Now, after you get all that stuff in there, you can finally make the call to getaddrinfo()!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "res",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct addrinfo",
                        "tag": "code"
                    }
                ],
                "content": "Of course, this is where the fun begins. The res will now point to a linked list of struct addrinfos, and you can go through this list to get all the addresses that match what you passed in with the hints.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_PASSIVE",
                        "tag": "code"
                    }
                ],
                "content": "Now, it\u2019s possible to get some addresses that don\u2019t work for one reason or another, so what the Linux man page does is loops through the list doing a call to socket() and connect() (or bind() if you\u2019re setting up a server with the AI_PASSIVE flag) until it succeeds.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "freeaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Finally, when you\u2019re done with the linked list, you need to call freeaddrinfo() to free up the memory (or it will be leaked, and Some People will get upset).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gai_strerror()",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or nonzero on error. If it returns nonzero, you can use the function gai_strerror() to get a printable version of the error code in the return value.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyname()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyname()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#getnameinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getnameinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getnameinfo()",
                        "tag": "a"
                    }
                ],
                "content": "gethostbyname(), getnameinfo()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Returns the name of the system",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Your system has a name. They all do. This is a slightly more Unixy thing than the rest of the networky stuff we\u2019ve been talking about, but it still has its uses.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    }
                ],
                "content": "For instance, you can get your host name, and then call gethostbyname() to find out your IP address.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "name",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NUL",
                        "tag": "code"
                    }
                ],
                "content": "The parameter name should point to a buffer that will hold the host name, and len is the size of that buffer in bytes. gethostname() won\u2019t overwrite the end of the buffer (it might return an error, or it might just stop writing), and it will NUL-terminate the string if there\u2019s room for it in the buffer.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyname()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyname()",
                        "tag": "a"
                    }
                ],
                "content": "gethostbyname()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Get an IP address for a hostname, or vice-versa",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            },
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getnameinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "PLEASE NOTE: these two functions are superseded by getaddrinfo() and getnameinfo()!",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    }
                ],
                "content": "PLEASE NOTE: these two functions are superseded by getaddrinfo() and getnameinfo()! In particular, gethostbyname() doesn\u2019t work well with IPv6.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    }
                ],
                "content": "These functions map back and forth between host names and IP addresses. For instance, if you have \u201cwww.example.com\u201d, you can use gethostbyname() to get its IP address and store it in a struct in_addr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "is",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getnameinfo()",
                        "tag": "code"
                    }
                ],
                "content": "Conversely, if you have a struct in_addr or a struct in6_addr, you can use gethostbyaddr() to get the hostname back. gethostbyaddr() is IPv6 compatible, but you should use the newer shinier getnameinfo() instead.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AI_CANONNAME",
                        "tag": "code"
                    }
                ],
                "content": "(If you have a string containing an IP address in dots-and-numbers format that you want to look up the hostname of, you\u2019d be better off using getaddrinfo() with the AI_CANONNAME flag.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct hostent",
                        "tag": "code"
                    }
                ],
                "content": "gethostbyname() takes a string like \u201cwww.yahoo.com\u201d, and returns a struct hostent which contains tons of information, including the IP address. (Other information is the official host name, a list of aliases, the address type, the length of the addresses, and the list of addresses\u2014it\u2019s a general-purpose structure that\u2019s pretty easy to use for our specific purposes once you see how.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "char*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof(struct in_addr)",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "type",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    }
                ],
                "content": "gethostbyaddr() takes a struct in_addr or struct in6_addr and brings you up a corresponding host name (if there is one), so it\u2019s sort of the reverse of gethostbyname(). As for parameters, even though addr is a char*, you actually want to pass in a pointer to a struct in_addr. len should be sizeof(struct in_addr), and type should be AF_INET.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct hostent",
                        "tag": "code"
                    }
                ],
                "content": "So what is this struct hostent that gets returned? It has a number of fields that contain information about the host in question.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct hostent",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    }
                ],
                "content": "Returns a pointer to a resultant struct hostent on success, or NULL on error.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "perror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "h_errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "herror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hstrerror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "perror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "strerror()",
                        "tag": "code"
                    }
                ],
                "content": "Instead of the normal perror() and all that stuff you\u2019d normally use for error reporting, these functions have parallel results in the variable h_errno, which can be printed using the functions herror() or hstrerror(). These work just like the classic errno, perror(), and strerror() functions you\u2019re used to.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#getaddrinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#getnameinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getnameinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getnameinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#gethostnameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostname()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostname()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#errnoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "errno",
                                "tag": "code"
                            }
                        ],
                        "content": "errno",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#perrorman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "perror()",
                                "tag": "code"
                            }
                        ],
                        "content": "perror()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#perrorman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "strerror()",
                                "tag": "code"
                            }
                        ],
                        "content": "strerror()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#structsockaddrman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "struct in_addr",
                                "tag": "code"
                            }
                        ],
                        "content": "struct in_addr",
                        "tag": "a"
                    }
                ],
                "content": "getaddrinfo(), getnameinfo(), gethostname(), errno, perror(), strerror(), struct in_addr",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Look up the host name and service name information for a given struct sockaddr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyaddr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getservbyport()",
                        "tag": "code"
                    }
                ],
                "content": "This function is the opposite of getaddrinfo(), that is, this function takes an already loaded struct sockaddr and does a name and service name lookup on it. It replaces the old gethostbyaddr() and getservbyport() functions.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sa",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "salen",
                        "tag": "code"
                    }
                ],
                "content": "You have to pass in a pointer to a struct sockaddr (which in actuality is probably a struct sockaddr_in or struct sockaddr_in6 that you\u2019ve cast) in the sa parameter, and the length of that struct in the salen.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "host",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "serv",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "hostlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "servlen",
                        "tag": "code"
                    }
                ],
                "content": "The resultant host name and service name will be written to the area pointed to by the host and serv parameters. Of course, you have to specify the max lengths of these buffers in hostlen and servlen.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NI_NOFQDN",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "host",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NI_NAMEREQD",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getnameinfo()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "host",
                        "tag": "code"
                    }
                ],
                "content": "Finally, there are several flags you can pass, but here a a couple good ones. NI_NOFQDN will cause the host to only contain the host name, not the whole domain name. NI_NAMEREQD will cause the function to fail if the name cannot be found with a DNS lookup (if you don\u2019t specify this flag and the name can\u2019t be found, getnameinfo() will put a string version of the IP address in host instead).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "As always, check your local man pages for the full scoop.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gai_strerror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or non-zero on error. If the return value is non-zero, it can be passed to gai_strerror() to get a human-readable string. See getaddrinfo for more information.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#getaddrinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyaddr()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyaddr()",
                        "tag": "a"
                    }
                ],
                "content": "getaddrinfo(), gethostbyaddr()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Return address info about the remote side of the connection",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "peer",
                        "tag": "em"
                    }
                ],
                "content": "Once you have either accept()ed a remote connection, or connect()ed to a server, you now have what is known as a peer. Your peer is simply the computer you\u2019re connected to, identified by an IP address and a port. So\u2026",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getpeername()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    }
                ],
                "content": "getpeername() simply returns a struct sockaddr_in filled with information about the machine you\u2019re connected to.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Why is it called a \u201cname\u201d? Well, there are a lot of different kinds of sockets, not just Internet Sockets like we\u2019re using in this guide, and so \u201cname\u201d was a nice generic term that covered all cases. In our case, though, the peer\u2019s \u201cname\u201d is it\u2019s IP address and port.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "addr",
                        "tag": "code"
                    }
                ],
                "content": "Although the function returns the size of the resultant address in len, you must preload len with the size of addr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#gethostnameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostname()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostname()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyname()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyname()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyaddr()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyaddr()",
                        "tag": "a"
                    }
                ],
                "content": "gethostname(), gethostbyname(), gethostbyaddr()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Holds the error code for the last system call",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "This is the variable that holds error information for a lot of system calls. If you\u2019ll recall, things like socket() and listen() return -1 on error, and they set the exact value of errno to let you know specifically which error occurred.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno.h",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EADDRINUSE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EPIPE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ECONNREFUSED",
                        "tag": "code"
                    }
                ],
                "content": "The header file errno.h lists a bunch of constant symbolic names for errors, such as EADDRINUSE, EPIPE, ECONNREFUSED, etc. Your local man pages will tell you what codes can be returned as an error, and you can use these at run time to handle different errors in different ways.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "perror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "strerror()",
                        "tag": "code"
                    }
                ],
                "content": "Or, more commonly, you can call perror() or strerror() to get a human-readable version of the error.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "One thing to note, for you multithreading enthusiasts, is that on most systems errno is defined in a threadsafe manner. (That is, it\u2019s not actually a global variable, but it behaves just like a global variable would in a single-threaded environment.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The value of the variable is the latest error to have transpired, which might be the code for \u201csuccess\u201d if the last action succeeded.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#perrorman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "perror()",
                                "tag": "code"
                            }
                        ],
                        "content": "perror()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#perrorman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "strerror()",
                                "tag": "code"
                            }
                        ],
                        "content": "strerror()",
                        "tag": "a"
                    }
                ],
                "content": "perror(), strerror()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Control socket descriptors",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This function is typically used to do file locking and other file-oriented stuff, but it also has a couple socket-related functions that you might see or use from time to time.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "cmd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "F_SETFL",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "arg",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fcntl()",
                        "tag": "code"
                    }
                ],
                "content": "Parameter s is the socket descriptor you wish to operate on, cmd should be set to F_SETFL, and arg can be one of the following commands. (Like I said, there\u2019s more to fcntl() than I\u2019m letting on here, but I\u2019m trying to stay socket-oriented.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fcntl()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fcntl()",
                        "tag": "code"
                    }
                ],
                "content": "Different uses of the fcntl() system call actually have different return values, but I haven\u2019t covered them here because they\u2019re not socket-related. See your local fcntl() man page for more information.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#blocking"
                        },
                        "children": [],
                        "content": "Blocking",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#sendman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "send()",
                                "tag": "code"
                            }
                        ],
                        "content": "send()",
                        "tag": "a"
                    }
                ],
                "content": "Blocking, send()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Convert multi-byte integer types from host byte order to network byte order",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "char",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "short int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "256",
                        "tag": "code"
                    }
                ],
                "content": "Just to make you really unhappy, different computers use different byte orderings internally for their multibyte integers (i.e.\u00a0any integer that\u2019s larger than a char). The upshot of this is that if you send() a two-byte short int from an Intel box to a Mac (before they became Intel boxes, too, I mean), what one computer thinks is the number 1, the other will think is the number 256, and vice-versa.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " The way to get around this problem is for everyone to put aside their differences and agree that Motorola and IBM had it right, and Intel did it the weird way, and so we all convert our byte orderings to \u201cbig-endian\u201d before sending them out. Since Intel is a \u201clittle-endian\u201d machine, it\u2019s far more politically correct to call our preferred byte ordering \u201cNetwork Byte Order\u201d. So these functions convert from your native byte order to network byte order and back again.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "(This means on Intel these functions swap all the bytes around, and on PowerPC they do nothing because the bytes are already in Network Byte Order. But you should always use them in your code anyway, since someone might want to build it on an Intel machine and still have things work properly.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "short",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "htonll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    }
                ],
                "content": "Note that the types involved are 32-bit (4 byte, probably int) and 16-bit (2 byte, very likely short) numbers. 64-bit machines might have a htonll() for 64-bit ints, but I\u2019ve not seen it. You\u2019ll just have to write your own.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "from",
                        "tag": "em"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "to",
                        "tag": "em"
                    }
                ],
                "content": "Anyway, the way these functions work is that you first decide if you\u2019re converting from host (your machine\u2019s) byte order or from network byte order. If \u201chost\u201d, the the first letter of the function you\u2019re going to call is \u201ch\u201d. Otherwise it\u2019s \u201cn\u201d for \u201cnetwork\u201d. The middle of the function name is always \u201cto\u201d because you\u2019re converting from one \u201cto\u201d another, and the penultimate letter shows what you\u2019re converting to. The last letter is the size of the data, \u201cs\u201d for short, or \u201cl\u201d for long. Thus:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Each function returns the converted value.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    }
                ],
                "content": "Convert IP addresses from a dots-and-number string to a struct in_addr and back",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "inet_ntop()",
                                "tag": "code"
                            },
                            {
                                "attributes": {},
                                "children": [],
                                "content": "inet_pton()",
                                "tag": "code"
                            }
                        ],
                        "content": "These functions are deprecated because they don\u2019t handle IPv6! Use (inet_ntop())[#inet_ntopman] or (inet_pton())[#inet_ntopman] instead! They are included here because they can still be found in the wild.",
                        "tag": "em"
                    }
                ],
                "content": "These functions are deprecated because they don\u2019t handle IPv6! Use (inet_ntop())[#inet_ntopman] or (inet_pton())[#inet_ntopman] instead! They are included here because they can still be found in the wild.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "connect()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "gethostbyname()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "coup d\u2019\u00c9tat",
                        "tag": "em"
                    }
                ],
                "content": "All of these functions convert from a struct in_addr (part of your struct sockaddr_in, most likely) to a string in dots-and-numbers format (e.g.\u00a0\u201c192.168.5.10\u201d) and vice-versa. If you have an IP address passed on the command line or something, this is the easiest way to get a struct in_addr to connect() to, or whatever. If you need more power, try some of the DNS functions like gethostbyname() or attempt a coup d\u2019\u00c9tat in your local country.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntoa()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "atoi()",
                        "tag": "code"
                    }
                ],
                "content": "The function inet_ntoa() converts a network address in a struct in_addr to a dots-and-numbers format string. The \u201cn\u201d in \u201cntoa\u201d stands for network, and the \u201ca\u201d stands for ASCII for historical reasons (so it\u2019s \u201cNetwork To ASCII\u201d\u2014the \u201ctoa\u201d suffix has an analogous friend in the C library called atoi() which converts an ASCII string to an integer).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_aton()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "in_addr_t",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    }
                ],
                "content": "The function inet_aton() is the opposite, converting from a dots-and-numbers string into a in_addr_t (which is the type of the field s_addr in your struct in_addr).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_addr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_aton()",
                        "tag": "code"
                    }
                ],
                "content": "Finally, the function inet_addr() is an older function that does basically the same thing as inet_aton(). It\u2019s theoretically deprecated, but you\u2019ll see it a lot and the police won\u2019t come get you if you use it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_aton()",
                        "tag": "code"
                    }
                ],
                "content": "inet_aton() returns non-zero if the address is a valid one, and it returns zero if the address is invalid.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntoa()",
                        "tag": "code"
                    }
                ],
                "content": "inet_ntoa() returns the dots-and-numbers string in a static buffer that is overwritten with each call to the function.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_addr()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "in_addr_t",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "255.255.255.255",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_aton()",
                        "tag": "code"
                    }
                ],
                "content": "inet_addr() returns the address as an in_addr_t, or -1 if there\u2019s an error. (That is the same result as if you tried to convert the string \u201c255.255.255.255\u201d, which is a valid IP address. This is why inet_aton() is better.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#inet_ntopman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "inet_ntop()",
                                "tag": "code"
                            }
                        ],
                        "content": "inet_ntop()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#inet_ntopman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "inet_pton()",
                                "tag": "code"
                            }
                        ],
                        "content": "inet_pton()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyname()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyname()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#gethostbynameman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "gethostbyaddr()",
                                "tag": "code"
                            }
                        ],
                        "content": "gethostbyaddr()",
                        "tag": "a"
                    }
                ],
                "content": "inet_ntop(), inet_pton(), gethostbyname(), gethostbyaddr()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Convert IP addresses to human-readable form and back.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "These functions are for dealing with human-readable IP addresses and converting them to their binary representation for use with various functions and system calls. The \u201cn\u201d stands for \u201cnetwork\u201d, and \u201cp\u201d for \u201cpresentation\u201d. Or \u201ctext presentation\u201d. But you can think of it as \u201cprintable\u201d. \u201cntop\u201d is \u201cnetwork to printable\u201d. See?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "192.0.2.180",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "2001:db8:8714:3a90::12",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntop()",
                        "tag": "code"
                    }
                ],
                "content": "Sometimes you don\u2019t want to look at a pile of binary numbers when looking at an IP address. You want it in a nice printable form, like 192.0.2.180, or 2001:db8:8714:3a90::12. In that case, inet_ntop() is for you.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntop()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "af",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "src",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "dst",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "size",
                        "tag": "code"
                    }
                ],
                "content": "inet_ntop() takes the address family in the af parameter (either AF_INET or AF_INET6). The src parameter should be a pointer to either a struct in_addr or struct in6_addr containing the address you wish to convert to a string. Finally dst and size are the pointer to the destination string and the maximum length of that string.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "dst",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INET_ADDRSTRLEN",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "INET6_ADDRSTRLEN",
                        "tag": "code"
                    }
                ],
                "content": "What should the maximum length of the dst string be? What is the maximum length for IPv4 and IPv6 addresses? Fortunately there are a couple of macros to help you out. The maximum lengths are: INET_ADDRSTRLEN and INET6_ADDRSTRLEN.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_pton()",
                        "tag": "code"
                    }
                ],
                "content": "Other times, you might have a string containing an IP address in readable form, and you want to pack it into a struct sockaddr_in or a struct sockaddr_in6. In that case, the opposite function inet_pton() is what you\u2019re after.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_pton()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "af",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "src",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "dst",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    }
                ],
                "content": "inet_pton() also takes an address family (either AF_INET or AF_INET6) in the af parameter. The src parameter is a pointer to a string containing the IP address in printable form. Lastly the dst parameter points to where the result should be stored, which is probably a struct in_addr or struct in6_addr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "These functions don\u2019t do DNS lookups\u2014you\u2019ll need getaddrinfo() for that.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_ntop()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "dst",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "inet_ntop() returns the dst parameter on success, or NULL on failure (and errno is set).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "inet_pton()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    }
                ],
                "content": "inet_pton() returns 1 on success. It returns -1 if there was an error (errno is set), or 0 if the input isn\u2019t a valid IP address.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#getaddrinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    }
                ],
                "content": "getaddrinfo()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Tell a socket to listen for incoming connections",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socket()",
                        "tag": "code"
                    }
                ],
                "content": "You can take your socket descriptor (made with the socket() system call) and tell it to listen for incoming connections. This is what differentiates the servers from the clients, guys.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "backlog",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "The backlog parameter can mean a couple different things depending on the system you on, but loosely it is how many pending connections you can have before the kernel starts rejecting new ones. So as the new connections come in, you should be quick to accept() them so that the backlog doesn\u2019t fill. Try setting it to 10 or so, and if your clients start getting \u201cConnection refused\u201d under heavy load, set it higher.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    }
                ],
                "content": "Before calling listen(), your server should call bind() to attach itself to a specific port number. That port number (on the server\u2019s IP address) will be the one that clients connect to.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#acceptman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "accept()",
                                "tag": "code"
                            }
                        ],
                        "content": "accept()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#bindman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "bind()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#socketman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "socket()",
                                "tag": "code"
                            }
                        ],
                        "content": "socket()",
                        "tag": "a"
                    }
                ],
                "content": "accept(), bind(), socket()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Print an error as a human-readable string",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Since so many functions return -1 on error and set the value of the variable errno to be some number, it would sure be nice if you could easily print that in a form that made sense to you.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "perror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    }
                ],
                "content": "Mercifully, perror() does that. If you want more description to be printed before the error, you can point the parameter s to it (or you can leave s as NULL and nothing additional will be printed).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ECONNRESET",
                        "tag": "code"
                    }
                ],
                "content": "In a nutshell, this function takes errno values, like ECONNRESET, and prints them nicely, like \u201cConnection reset by peer.\u201d",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "strerror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "perror()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "The function strerror() is very similar to perror(), except it returns a pointer to the error message string for a given value (you usually pass in the variable errno).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "strerror()",
                        "tag": "code"
                    }
                ],
                "content": "strerror() returns a pointer to the error message string.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#errnoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "errno",
                                "tag": "code"
                            }
                        ],
                        "content": "errno",
                        "tag": "a"
                    }
                ],
                "content": "errno",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Test for events on multiple sockets simultaneously",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "This function is very similar to select() in that they both watch sets of file descriptors for events, such as incoming data ready to recv(), socket ready to send() data to, out-of-band data ready to recv(), errors, etc.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "nfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct pollfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ufds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "timeout",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    }
                ],
                "content": "The basic idea is that you pass an array of nfds struct pollfds in ufds, along with a timeout in milliseconds (1000 milliseconds in a second). The timeout can be negative if you want to wait forever. If no event happens on any of the socket descriptors by the timeout, poll() will return.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct pollfd",
                        "tag": "code"
                    }
                ],
                "content": "Each element in the array of struct pollfds represents one socket descriptor, and contains the following fields:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct pollfd",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "revents",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "events",
                        "tag": "code"
                    }
                ],
                "content": "Before calling poll(), load fd with the socket descriptor (if you set fd to a negative number, this struct pollfd is ignored and its revents field is set to zero) and then construct the events field by bitwise-ORing the following macros:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "revents",
                        "tag": "code"
                    }
                ],
                "content": "Once the poll() call returns, the revents field will be constructed as a bitwise-OR of the above fields, telling you which descriptors actually have had that event occur. Additionally, these other fields might be present:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "ufds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns the number of elements in the ufds array that have had event occur on them; this can be zero if the timeout occurred. Also returns -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#selectman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            }
                        ],
                        "content": "select()",
                        "tag": "a"
                    }
                ],
                "content": "select()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Receive data on a socket",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    }
                ],
                "content": "Once you have a socket up and connected, you can read incoming data from the remote side using the recv() (for TCP SOCK_STREAM sockets) and recvfrom() (for UDP SOCK_DGRAM sockets).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "buf",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "flags",
                        "tag": "code"
                    }
                ],
                "content": "Both functions take the socket descriptor s, a pointer to the buffer buf, the size (in bytes) of the buffer len, and a set of flags that control how the functions work.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "from",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fromlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "fromlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "from",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "Additionally, the recvfrom() takes a struct sockaddr*, from that will tell you where the data came from, and will fill in fromlen with the size of struct sockaddr. (You must also initialize fromlen to be the size of from or struct sockaddr.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "flags",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "So what wondrous flags can you pass into this function? Here are some of them, but you should check your local man pages for more information and what is actually supported on your system. You bitwise-or these together, or just set flags to 0 if you want it to be a regular vanilla recv().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "poll()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    }
                ],
                "content": "When you call recv(), it will block until there is some data to read. If you want to not block, set the socket to non-blocking or check with select() or poll() to see if there is incoming data before calling recv() or recvfrom().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns the number of bytes actually received (which might be less than you requested in the len parameter), or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    }
                ],
                "content": "If the remote side has closed the connection, recv() will return 0. This is the normal method for determining if the remote side has closed the connection. Normality is good, rebel!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#sendman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "send()",
                                "tag": "code"
                            }
                        ],
                        "content": "send()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#sendman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "sendto()",
                                "tag": "code"
                            }
                        ],
                        "content": "sendto()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#selectman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "select()",
                                "tag": "code"
                            }
                        ],
                        "content": "select()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#pollman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "poll()",
                                "tag": "code"
                            }
                        ],
                        "content": "poll()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#blocking"
                        },
                        "children": [],
                        "content": "Blocking",
                        "tag": "a"
                    }
                ],
                "content": "send(), sendto(), select(), poll(), Blocking",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Check if sockets descriptors are ready to read/write",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "The select() function gives you a way to simultaneously check multiple sockets to see if they have data waiting to be recv()d, or if you can send() data to them without blocking, or if some exception has occurred.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "FD_SET()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "readfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "writefds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "exceptfds",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    }
                ],
                "content": "You populate your sets of socket descriptors using the macros, like FD_SET(), above. Once you have the set, you pass it into the function as one of the following parameters: readfds if you want to know when any of the sockets in the set is ready to recv() data, writefds if any of the sockets is ready to send() data to, and/or exceptfds if you need to know when an exception (error) occurs on any of the sockets. Any or all of these parameters can be NULL if you\u2019re not interested in those types of events. After select() returns, the values in the sets will be changed to show which are ready for reading or writing, and which have exceptions.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "n",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    }
                ],
                "content": "The first parameter, n is the highest-numbered socket descriptor (they\u2019re just ints, remember?) plus one.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "timeout",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct timeval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tv_sec",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "tv_usec",
                        "tag": "code"
                    }
                ],
                "content": "Lastly, the struct timeval, timeout, at the end\u2014this lets you tell select() how long to check these sets for. It\u2019ll return after the timeout, or when an event occurs, whichever is first. The struct timeval has two fields: tv_sec is the number of seconds, to which is added tv_usec, the number of microseconds (1,000,000 microseconds in a second).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "The helper macros do the following:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "select()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "read()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "O_NONBLOCK",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "EWOULDBLOCK",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#fcntlman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "fcntl()",
                                "tag": "code"
                            }
                        ],
                        "content": "fcntl() man page",
                        "tag": "a"
                    }
                ],
                "content": "Note for Linux users: Linux\u2019s select() can return \u201cready-to-read\u201d and then not actually be ready to read, thus causing the subsequent read() call to block. You can work around this bug by setting O_NONBLOCK flag on the receiving socket so it errors with EWOULDBLOCK, then ignoring this error if it occurs. See the fcntl() man page for more info on setting a socket to non-blocking.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "0",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns the number of descriptors in the set on success, 0 if the timeout was reached, or -1 on error (and errno will be set accordingly). Also, the sets are modified to show which sockets are ready.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#pollman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "poll()",
                                "tag": "code"
                            }
                        ],
                        "content": "poll()",
                        "tag": "a"
                    }
                ],
                "content": "poll()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Set various options for a socket",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Sockets are fairly configurable beasts. In fact, they are so configurable, I\u2019m not even going to cover it all here. It\u2019s probably system-dependent anyway. But I will talk about the basics.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man 7 socket",
                        "tag": "code"
                    }
                ],
                "content": "Obviously, these functions get and set certain options on a socket. On a Linux box, all the socket information is in the man page for socket in section 7. (Type: \u201cman 7 socket\u201d to get all these goodies.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOL_SOCKET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optname",
                        "tag": "code"
                    }
                ],
                "content": "As for parameters, s is the socket you\u2019re talking about, level should be set to SOL_SOCKET. Then you set the optname to the name you\u2019re interested in. Again, see your man page for all the options, but here are some of the most fun ones:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "NULL",
                        "tag": "code"
                    }
                ],
                "content": "As for the parameter optval, it\u2019s usually a pointer to an int indicating the value in question. For booleans, zero is false, and non-zero is true. And that\u2019s an absolute fact, unless it\u2019s different on your system. If there is no parameter to be passed, optval can be NULL.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optlen",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sizeof(int)",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getsockopt()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "socklen_t",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optval",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getsockopt()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "optlen",
                        "tag": "code"
                    }
                ],
                "content": "The final parameter, optlen, should be set to the length of optval, probably sizeof(int), but varies depending on the option. Note that in the case of getsockopt(), this is a pointer to a socklen_t, and it specifies the maximum size object that will be stored in optval (to prevent buffer overflows). And getsockopt() will modify the value of optlen to reflect the number of bytes actually set.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Warning",
                        "tag": "strong"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "char",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "'1'",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "int",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man setsockopt",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "man 7 socket",
                        "tag": "code"
                    }
                ],
                "content": "Warning: on some systems (notably Sun and Windows), the option can be a char instead of an int, and is set to, for example, a character value of '1' instead of an int value of 1. Again, check your own man pages for more info with \u201cman setsockopt\u201d and \u201cman 7 socket\u201d!",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#fcntlman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "fcntl()",
                                "tag": "code"
                            }
                        ],
                        "content": "fcntl()",
                        "tag": "a"
                    }
                ],
                "content": "fcntl()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Send data out over a socket",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_STREAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SOCK_DGRAM",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    }
                ],
                "content": "These functions send data to a socket. Generally speaking, send() is used for TCP SOCK_STREAM connected sockets, and sendto() is used for UDP SOCK_DGRAM unconnected datagram sockets. With the unconnected sockets, you must specify the destination of a packet each time you send one, and that\u2019s why the last parameters of sendto() define where the packet is going.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sendto()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "buf",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "len",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "flags",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "flags",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    }
                ],
                "content": "With both send() and sendto(), the parameter s is the socket, buf is a pointer to the data you want to send, len is the number of bytes you want to send, and flags allows you to specify more information about how the data is to be sent. Set flags to zero if you want it to be \u201cnormal\u201d data. Here are some of the commonly used flags, but check your local send() man pages for more details:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    },
                    {
                        "attributes": {
                            "href": "#sendall"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "send()",
                                "tag": "code"
                            }
                        ],
                        "content": "handling partial send()s",
                        "tag": "a"
                    }
                ],
                "content": "Returns the number of bytes actually sent, or -1 on error (and errno will be set accordingly). Note that the number of bytes actually sent might be less than the number you asked it to send! See the section on handling partial send()s for a helper function to get around this.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SIGPIPE",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "MSG_NOSIGNAL",
                        "tag": "code"
                    }
                ],
                "content": "Also, if the socket has been closed by either side, the process calling send() will get the signal SIGPIPE. (Unless send() was called with the MSG_NOSIGNAL flag.)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#recvman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "recv()",
                                "tag": "code"
                            }
                        ],
                        "content": "recv()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#recvman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "recvfrom()",
                                "tag": "code"
                            }
                        ],
                        "content": "recvfrom()",
                        "tag": "a"
                    }
                ],
                "content": "recv(), recvfrom()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Stop further sends and receives on a socket",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    }
                ],
                "content": "That\u2019s it! I\u2019ve had it! No more send()s are allowed on this socket, but I still want to recv() data on it! Or vice-versa! How can I do this?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "shutdown()",
                        "tag": "code"
                    }
                ],
                "content": "When you close() a socket descriptor, it closes both sides of the socket for reading and writing, and frees the socket descriptor. If you just want to close one side or the other, you can use this shutdown() call.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "how",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "how",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SHUT_RD",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recv()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SHUT_WR",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "send()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "SHUT_RDWR",
                        "tag": "code"
                    }
                ],
                "content": "As for parameters, s is obviously the socket you want to perform this action on, and what action that is can be specified with the how parameter. how can be SHUT_RD to prevent further recv()s, SHUT_WR to prohibit further send()s, or SHUT_RDWR to do both.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "shutdown()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "close()",
                        "tag": "code"
                    }
                ],
                "content": "Note that shutdown() doesn\u2019t free up the socket descriptor, so you still have to eventually close() the socket even if it has been fully shut down.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "This is a rarely used system call.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "Returns zero on success, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#closeman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "close()",
                                "tag": "code"
                            }
                        ],
                        "content": "close()",
                        "tag": "a"
                    }
                ],
                "content": "close()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Allocate a socket descriptor",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "listen()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "bind()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    }
                ],
                "content": "Returns a new socket descriptor that you can use to do sockety things with. This is generally the first call in the whopping process of writing a socket program, and you can use the result for subsequent calls to listen(), bind(), accept(), or a variety of other functions.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "In usual usage, you get the values for these parameters from a call to getaddrinfo(), as shown in the example below. But you can fill them in by hand if you really want to.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "-1",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "errno",
                        "tag": "code"
                    }
                ],
                "content": "The new socket descriptor to be used in subsequent calls, or -1 on error (and errno will be set accordingly).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#acceptman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "accept()",
                                "tag": "code"
                            }
                        ],
                        "content": "accept()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#bindman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "bind()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#getaddrinfoman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "getaddrinfo()",
                                "tag": "code"
                            }
                        ],
                        "content": "getaddrinfo()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#listenman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "listen()",
                                "tag": "code"
                            }
                        ],
                        "content": "listen()",
                        "tag": "a"
                    }
                ],
                "content": "accept(), bind(), getaddrinfo(), listen()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "Structures for handling internet addresses",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "getaddrinfo()",
                        "tag": "code"
                    }
                ],
                "content": "These are the basic structures for all syscalls and functions that deal with internet addresses. Often you\u2019ll use getaddrinfo() to fill these structures out, and then will read them when you have to.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "In memory, the struct sockaddr_in and struct sockaddr_in6 share the same beginning structure as struct sockaddr, and you can freely cast the pointer of one type to the other without any harm, except the possible end of the universe.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr*",
                        "tag": "code"
                    }
                ],
                "content": "Just kidding on that end-of-the-universe thing\u2026if the universe does end when you cast a struct sockaddr_in* to a struct sockaddr*, I promise you it\u2019s pure coincidence and you shouldn\u2019t even worry about it.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6*",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage*",
                        "tag": "code"
                    }
                ],
                "content": "So, with that in mind, remember that whenever a function says it takes a struct sockaddr* you can cast your struct sockaddr_in*, struct sockaddr_in6*, or struct sockaddr_storage* to that type with ease and safety.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "AF_INET",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_port",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_addr",
                        "tag": "code"
                    }
                ],
                "content": "struct sockaddr_in is the structure used with IPv4 addresses (e.g. \u201c192.0.2.10\u201d). It holds an address family (AF_INET), a port in sin_port, and an IPv4 address in sin_addr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "sin_zero",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "memset()",
                        "tag": "code"
                    }
                ],
                "content": "There\u2019s also this sin_zero field in struct sockaddr_in which some people claim must be set to zero. Other people don\u2019t claim anything about it (the Linux documentation doesn\u2019t even mention it at all), and setting it to zero doesn\u2019t seem to be actually necessary. So, if you feel like it, set it to zero using memset().",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in_addr",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "union",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "#define",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "s_addr",
                        "tag": "code"
                    }
                ],
                "content": "Now, that struct in_addr is a weird beast on different systems. Sometimes it\u2019s a crazy union with all kinds of #defines and other nonsense. But what you should do is only use the s_addr field in this structure, because many systems only implement that one.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_in6",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct in6_addr",
                        "tag": "code"
                    }
                ],
                "content": "struct sockaddr_in6 and struct in6_addr are very similar, except they\u2019re used for IPv6.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "accept()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "recvfrom()",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr_storage",
                        "tag": "code"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": "struct sockaddr",
                        "tag": "code"
                    }
                ],
                "content": "struct sockaddr_storage is a struct you can pass to accept() or recvfrom() when you\u2019re trying to write IP version-agnostic code and you don\u2019t know if the new address is going to be IPv4 or IPv6. The struct sockaddr_storage structure is large enough to hold both types, unlike the original small struct sockaddr.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "#acceptman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "accept()",
                                "tag": "code"
                            }
                        ],
                        "content": "accept()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#bindman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "bind()",
                                "tag": "code"
                            }
                        ],
                        "content": "bind()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#connectman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "connect()",
                                "tag": "code"
                            }
                        ],
                        "content": "connect()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#inet_ntoaman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "inet_aton()",
                                "tag": "code"
                            }
                        ],
                        "content": "inet_aton()",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "#inet_ntoaman"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "inet_ntoa()",
                                "tag": "code"
                            }
                        ],
                        "content": "inet_ntoa()",
                        "tag": "a"
                    }
                ],
                "content": "accept(), bind(), connect(), inet_aton(), inet_ntoa()",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "You\u2019ve come this far, and now you\u2019re screaming for more! Where else can you go to learn more about all this stuff?",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "mailto:beej@beej.us"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "beej@beej.us",
                                "tag": "code"
                            }
                        ],
                        "content": "beej@beej.us",
                        "tag": "a"
                    },
                    {
                        "attributes": {},
                        "children": [],
                        "content": ":-)",
                        "tag": "code"
                    }
                ],
                "content": "For old-school actual hold-it-in-your-hand pulp paper books, try some of the following excellent books. These redirect to affiliate links with a popular bookseller, giving me nice kickbacks. If you\u2019re merely feeling generous, you can paypal a donation to beej@beej.us. :-)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Unix Network Programming, volumes 1-2",
                        "tag": "strong"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/unixnet1"
                        },
                        "children": [],
                        "content": "978-0131411555",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn49",
                            "id": "fnref49",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "49",
                                "tag": "sup"
                            }
                        ],
                        "content": "49",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/unixnet2"
                        },
                        "children": [],
                        "content": "978-0130810816",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn50",
                            "id": "fnref50",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "50",
                                "tag": "sup"
                            }
                        ],
                        "content": "50",
                        "tag": "a"
                    }
                ],
                "content": "Unix Network Programming, volumes 1-2 by W. Richard Stevens. Published by Addison-Wesley Professional and Prentice Hall. ISBNs for volumes 1-2: 978-013141155549, 978-013081081650.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Internetworking with TCP/IP, volume I",
                        "tag": "strong"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/intertcp1"
                        },
                        "children": [],
                        "content": "978-0136085300",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn51",
                            "id": "fnref51",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "51",
                                "tag": "sup"
                            }
                        ],
                        "content": "51",
                        "tag": "a"
                    }
                ],
                "content": "Internetworking with TCP/IP, volume I by Douglas E. Comer. Published by Pearson. ISBN 978-013608530051.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "TCP/IP Illustrated, volumes 1-3",
                        "tag": "strong"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/tcpi1"
                        },
                        "children": [],
                        "content": "978-0201633467",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn52",
                            "id": "fnref52",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "52",
                                "tag": "sup"
                            }
                        ],
                        "content": "52",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/tcpi2"
                        },
                        "children": [],
                        "content": "978-0201633542",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn53",
                            "id": "fnref53",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "53",
                                "tag": "sup"
                            }
                        ],
                        "content": "53",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/tcpi3"
                        },
                        "children": [],
                        "content": "978-0201634952",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn54",
                            "id": "fnref54",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "54",
                                "tag": "sup"
                            }
                        ],
                        "content": "54",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/tcpi123"
                        },
                        "children": [],
                        "content": "978-0201776317",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn55",
                            "id": "fnref55",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "55",
                                "tag": "sup"
                            }
                        ],
                        "content": "55",
                        "tag": "a"
                    }
                ],
                "content": "TCP/IP Illustrated, volumes 1-3 by W. Richard Stevens and Gary R. Wright. Published by Addison Wesley. ISBNs for volumes 1, 2, and 3 (and a 3-volume set): 978-020163346752, 978-020163354253, 978-020163495254, (978-020177631755).",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "TCP/IP Network Administration",
                        "tag": "strong"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/tcpna"
                        },
                        "children": [],
                        "content": "978-0596002978",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn56",
                            "id": "fnref56",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "56",
                                "tag": "sup"
                            }
                        ],
                        "content": "56",
                        "tag": "a"
                    }
                ],
                "content": "TCP/IP Network Administration by Craig Hunt. Published by O\u2019Reilly & Associates, Inc. ISBN 978-059600297856.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [],
                        "content": "Advanced Programming in the UNIX Environment",
                        "tag": "strong"
                    },
                    {
                        "attributes": {
                            "href": "https://beej.us/guide/url/advunix"
                        },
                        "children": [],
                        "content": "978-0321637734",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn57",
                            "id": "fnref57",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "57",
                                "tag": "sup"
                            }
                        ],
                        "content": "57",
                        "tag": "a"
                    }
                ],
                "content": "Advanced Programming in the UNIX Environment by W. Richard Stevens. Published by Addison Wesley. ISBN 978-032163773457.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "On the web:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html"
                                },
                                "children": [],
                                "content": "BSD Sockets: A Quick And Dirty Primer",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn58",
                                    "id": "fnref58",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "58",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "58",
                                "tag": "a"
                            }
                        ],
                        "content": "BSD Sockets: A Quick And Dirty Primer58",
                        "tag": "strong"
                    }
                ],
                "content": "BSD Sockets: A Quick And Dirty Primer58 (Unix system programming info, too!)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://developerweb.net/?f=70"
                                },
                                "children": [],
                                "content": "The Unix Socket FAQ",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn59",
                                    "id": "fnref59",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "59",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "59",
                                "tag": "a"
                            }
                        ],
                        "content": "The Unix Socket FAQ59",
                        "tag": "strong"
                    }
                ],
                "content": "The Unix Socket FAQ59",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/"
                                },
                                "children": [],
                                "content": "TCP/IP FAQ",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn60",
                                    "id": "fnref60",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "60",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "60",
                                "tag": "a"
                            }
                        ],
                        "content": "TCP/IP FAQ60",
                        "tag": "strong"
                    }
                ],
                "content": "TCP/IP FAQ60",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tangentsoft.net/wskfaq/"
                                },
                                "children": [],
                                "content": "The Winsock FAQ",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn61",
                                    "id": "fnref61",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "61",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "61",
                                "tag": "a"
                            }
                        ],
                        "content": "The Winsock FAQ61",
                        "tag": "strong"
                    }
                ],
                "content": "The Winsock FAQ61",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "And here are some relevant Wikipedia pages:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://en.wikipedia.org/wiki/Berkeley_sockets"
                                },
                                "children": [],
                                "content": "Berkeley Sockets",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn62",
                                    "id": "fnref62",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "62",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "62",
                                "tag": "a"
                            }
                        ],
                        "content": "Berkeley Sockets62",
                        "tag": "strong"
                    }
                ],
                "content": "Berkeley Sockets62",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://en.wikipedia.org/wiki/Internet_Protocol"
                                },
                                "children": [],
                                "content": "Internet Protocol (IP)",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn63",
                                    "id": "fnref63",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "63",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "63",
                                "tag": "a"
                            }
                        ],
                        "content": "Internet Protocol (IP)63",
                        "tag": "strong"
                    }
                ],
                "content": "Internet Protocol (IP)63",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://en.wikipedia.org/wiki/Transmission_Control_Protocol"
                                },
                                "children": [],
                                "content": "Transmission Control Protocol (TCP)",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn64",
                                    "id": "fnref64",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "64",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "64",
                                "tag": "a"
                            }
                        ],
                        "content": "Transmission Control Protocol (TCP)64",
                        "tag": "strong"
                    }
                ],
                "content": "Transmission Control Protocol (TCP)64",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://en.wikipedia.org/wiki/User_Datagram_Protocol"
                                },
                                "children": [],
                                "content": "User Datagram Protocol (UDP)",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn65",
                                    "id": "fnref65",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "65",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "65",
                                "tag": "a"
                            }
                        ],
                        "content": "User Datagram Protocol (UDP)65",
                        "tag": "strong"
                    }
                ],
                "content": "User Datagram Protocol (UDP)65",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://en.wikipedia.org/wiki/Client-server"
                                },
                                "children": [],
                                "content": "Client-Server",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn66",
                                    "id": "fnref66",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "66",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "66",
                                "tag": "a"
                            }
                        ],
                        "content": "Client-Server66",
                        "tag": "strong"
                    }
                ],
                "content": "Client-Server66",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://en.wikipedia.org/wiki/Serialization"
                                },
                                "children": [],
                                "content": "Serialization",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn67",
                                    "id": "fnref67",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "67",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "67",
                                "tag": "a"
                            }
                        ],
                        "content": "Serialization67",
                        "tag": "strong"
                    }
                ],
                "content": "Serialization67 (packing and unpacking data)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": "",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://www.rfc-editor.org/"
                        },
                        "children": [],
                        "content": "RFCs",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn68",
                            "id": "fnref68",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "68",
                                "tag": "sup"
                            }
                        ],
                        "content": "68",
                        "tag": "a"
                    }
                ],
                "content": "RFCs68\u2014the real dirt! These are documents that describe assigned numbers, programming APIs, and protocols that are used on the Internet. I\u2019ve included links to a few of them here for your enjoyment, so grab a bucket of popcorn and put on your thinking cap:",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc1"
                                },
                                "children": [],
                                "content": "RFC 1",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn69",
                                    "id": "fnref69",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "69",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "69",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 169",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 169 \u2014The First RFC; this gives you an idea of what the \u201cInternet\u201d was like just as it was coming to life, and an insight into how it was being designed from the ground up. (This RFC is completely obsolete, obviously!)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc768"
                                },
                                "children": [],
                                "content": "RFC 768",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn70",
                                    "id": "fnref70",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "70",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "70",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 76870",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 76870 \u2014The User Datagram Protocol (UDP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc791"
                                },
                                "children": [],
                                "content": "RFC 791",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn71",
                                    "id": "fnref71",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "71",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "71",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 79171",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 79171 \u2014The Internet Protocol (IP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc793"
                                },
                                "children": [],
                                "content": "RFC 793",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn72",
                                    "id": "fnref72",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "72",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "72",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 79372",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 79372 \u2014The Transmission Control Protocol (TCP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc854"
                                },
                                "children": [],
                                "content": "RFC 854",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn73",
                                    "id": "fnref73",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "73",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "73",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 85473",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 85473 \u2014The Telnet Protocol",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc959"
                                },
                                "children": [],
                                "content": "RFC 959",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn74",
                                    "id": "fnref74",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "74",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "74",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 95974",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 95974 \u2014File Transfer Protocol (FTP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc1350"
                                },
                                "children": [],
                                "content": "RFC 1350",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn75",
                                    "id": "fnref75",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "75",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "75",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 135075",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 135075 \u2014The Trivial File Transfer Protocol (TFTP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc1459"
                                },
                                "children": [],
                                "content": "RFC 1459",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn76",
                                    "id": "fnref76",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "76",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "76",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 145976",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 145976 \u2014Internet Relay Chat Protocol (IRC)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc1918"
                                },
                                "children": [],
                                "content": "RFC 1918",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn77",
                                    "id": "fnref77",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "77",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "77",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 191877",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 191877 \u2014Address Allocation for Private Internets",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc2131"
                                },
                                "children": [],
                                "content": "RFC 2131",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn78",
                                    "id": "fnref78",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "78",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "78",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 213178",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 213178 \u2014Dynamic Host Configuration Protocol (DHCP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc2616"
                                },
                                "children": [],
                                "content": "RFC 2616",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn79",
                                    "id": "fnref79",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "79",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "79",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 261679",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 261679 \u2014Hypertext Transfer Protocol (HTTP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc2821"
                                },
                                "children": [],
                                "content": "RFC 2821",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn80",
                                    "id": "fnref80",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "80",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "80",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 282180",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 282180 \u2014Simple Mail Transfer Protocol (SMTP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc3330"
                                },
                                "children": [],
                                "content": "RFC 3330",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn81",
                                    "id": "fnref81",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "81",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "81",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 333081",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 333081 \u2014Special-Use IPv4 Addresses",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc3493"
                                },
                                "children": [],
                                "content": "RFC 3493",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn82",
                                    "id": "fnref82",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "82",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "82",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 349382",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 349382 \u2014Basic Socket Interface Extensions for IPv6",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc3542"
                                },
                                "children": [],
                                "content": "RFC 3542",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn83",
                                    "id": "fnref83",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "83",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "83",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 354283",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 354283 \u2014Advanced Sockets Application Program Interface (API) for IPv6",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc3849"
                                },
                                "children": [],
                                "content": "RFC 3849",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn84",
                                    "id": "fnref84",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "84",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "84",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 384984",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 384984 \u2014IPv6 Address Prefix Reserved for Documentation",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc3920"
                                },
                                "children": [],
                                "content": "RFC 3920",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn85",
                                    "id": "fnref85",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "85",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "85",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 392085",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 392085 \u2014Extensible Messaging and Presence Protocol (XMPP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc3977"
                                },
                                "children": [],
                                "content": "RFC 3977",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn86",
                                    "id": "fnref86",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "86",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "86",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 397786",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 397786 \u2014Network News Transfer Protocol (NNTP)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc4193"
                                },
                                "children": [],
                                "content": "RFC 4193",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn87",
                                    "id": "fnref87",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "87",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "87",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 419387",
                        "tag": "strong"
                    }
                ],
                "content": "RFC 419387 \u2014Unique Local IPv6 Unicast Addresses",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {},
                        "children": [
                            {
                                "attributes": {
                                    "href": "https://tools.ietf.org/html/rfc4506"
                                },
                                "children": [],
                                "content": "RFC 4506",
                                "tag": "a"
                            },
                            {
                                "attributes": {
                                    "class": [
                                        "footnote-ref"
                                    ],
                                    "href": "#fn88",
                                    "id": "fnref88",
                                    "role": "doc-noteref"
                                },
                                "children": [
                                    {
                                        "attributes": {},
                                        "children": [],
                                        "content": "88",
                                        "tag": "sup"
                                    }
                                ],
                                "content": "88",
                                "tag": "a"
                            }
                        ],
                        "content": "RFC 450688",
                        "tag": "strong"
                    }
                ],
                "content": " RFC 450688 \u2014External Data Representation Standard (XDR)",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "href": "https://tools.ietf.org/rfc/"
                        },
                        "children": [],
                        "content": "searching and browsing RFCs",
                        "tag": "a"
                    },
                    {
                        "attributes": {
                            "class": [
                                "footnote-ref"
                            ],
                            "href": "#fn89",
                            "id": "fnref89",
                            "role": "doc-noteref"
                        },
                        "children": [
                            {
                                "attributes": {},
                                "children": [],
                                "content": "89",
                                "tag": "sup"
                            }
                        ],
                        "content": "89",
                        "tag": "a"
                    }
                ],
                "content": "The IETF has a nice online tool for searching and browsing RFCs89.",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [],
                "content": " ",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref1",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.linux.com/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref2",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://bsd.org/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref3",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://learn.microsoft.com/en-us/windows/wsl/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref4",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://cygwin.com/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref5",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.tallyhawk.net/WinsockExamples/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref6",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "http://www.catb.org/~esr/faqs/smart-questions.html\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref7",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/telnot.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref8",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc854\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref9",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc793\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref10",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc791\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref11",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc768\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref12",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc791\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref13",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Vint_Cerf\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref14",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/ELIZA\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref15",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.iana.org/assignments/port-numbers\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref16",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Doom_(1993_video_game)\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref17",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Wilford_Brimley\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref18",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc1918\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref19",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc4193\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref20",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.iana.org/assignments/port-numbers\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref21",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/showip.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref22",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc1413\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref23",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/server.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref24",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/client.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref25",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/listener.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref26",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/talker.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref27",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://libevent.org/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref28",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/poll.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref29",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/pollserver.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref30",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://libevent.org/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref31",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/select.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref32",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/selectserver.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref33",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Internet_Relay_Chat\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref34",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/pack.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref35",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/IEEE_754\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref36",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/ieee754.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref37",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/tpop\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref38",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://github.com/protobuf-c/protobuf-c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref39",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/pack2.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref40",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/pack2.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref41",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc4506\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref42",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/bgnet/source/examples/broadcaster.c\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref43",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "http://www.unpbook.com/src.html\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref44",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "http://www.unpbook.com/src.html\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref45",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.openssl.org/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref46",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://stackoverflow.com/questions/21323023/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref47",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.iana.org/assignments/port-numbers\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref48",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.iana.org/assignments/port-numbers\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref49",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/unixnet1\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref50",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/unixnet2\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref51",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/intertcp1\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref52",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/tcpi1\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref53",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/tcpi2\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref54",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/tcpi3\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref55",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/tcpi123\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref56",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/tcpna\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref57",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://beej.us/guide/url/advunix\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref58",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref59",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://developerweb.net/?f=70\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref60",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref61",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tangentsoft.net/wskfaq/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref62",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Berkeley_sockets\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref63",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Internet_Protocol\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref64",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Transmission_Control_Protocol\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref65",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/User_Datagram_Protocol\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref66",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Client-server\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref67",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://en.wikipedia.org/wiki/Serialization\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref68",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://www.rfc-editor.org/\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref69",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc1\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref70",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc768\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref71",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc791\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref72",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc793\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref73",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc854\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref74",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc959\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref75",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc1350\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref76",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc1459\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref77",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc1918\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref78",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc2131\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref79",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc2616\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref80",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc2821\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref81",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc3330\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref82",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc3493\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref83",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc3542\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref84",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc3849\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref85",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc3920\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref86",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc3977\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref87",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc4193\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref88",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/html/rfc4506\u21a9\ufe0e",
                "tag": "p"
            },
            {
                "attributes": {},
                "children": [
                    {
                        "attributes": {
                            "class": [
                                "footnote-back"
                            ],
                            "href": "#fnref89",
                            "role": "doc-backlink"
                        },
                        "children": [],
                        "content": "\u21a9\ufe0e",
                        "tag": "a"
                    }
                ],
                "content": "https://tools.ietf.org/rfc/\u21a9\ufe0e",
                "tag": "p"
            }
        ]
    ],
    "xpath": []
}